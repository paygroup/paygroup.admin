schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

type Balance {
  balance: Float!
  currency: CURRENCY!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

enum CURRENCY {
  CFD
  USD
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input InviteInput {
  group_id: String!
  receiver_id: String
  receiver_phone: String
  sender_id: String!
}

type InviteOutput {
  invite_with_whatsapp: Boolean
  invited_already: Boolean
  invited_successfully: Boolean
}

input PeriodCompletionActionInput {
  group_id: String!
}

type PeriodCompletionActionOutput {
  ok: Boolean
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

input TestMessageInput {
  message: String!
  user_id: String!
}

type TestMessageOutput {
  message: String!
}

"""
Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviderRequests {
  id: uuid!
  options(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_append_input {
  options: jsonb
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  options: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  provider_requests_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authProviderRequests_delete_at_path_input {
  options: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authProviderRequests_delete_elem_input {
  options: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authProviderRequests_delete_key_input {
  options: String
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  options: jsonb
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  options: order_by
}

"""primary key columns input for table: authProviderRequests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_prepend_input {
  options: jsonb
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  options
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  options: jsonb
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  options
}

input authProviderRequests_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authProviderRequests_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authProviderRequests_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authProviderRequests_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authProviderRequests_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authProviderRequests_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authProviderRequests_set_input
  where: authProviderRequests_bool_exp!
}

"""
List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: authProviders"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

input authProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authProviders_set_input
  where: authProviders_bool_exp!
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  refreshToken: uuid!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  refreshToken: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """
  unique or primary key constraint on columns "refresh_token"
  """
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authRefreshTokens"""
input authRefreshTokens_pk_columns_input {
  refreshToken: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

input authRefreshTokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokens_set_input
  where: authRefreshTokens_bool_exp!
}

"""
Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  usersByDefaultRole: users_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: authRoles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

input authRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRoles_set_input
  where: authRoles_bool_exp!
}

"""
User webauthn authenticators. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserAuthenticators {
  counter: bigint!
  credentialId: String!
  credentialPublicKey: bytea
  id: uuid!
  nickname: String
  transports: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_authenticators"
"""
type authUserAuthenticators_aggregate {
  aggregate: authUserAuthenticators_aggregate_fields
  nodes: [authUserAuthenticators!]!
}

"""
aggregate fields of "auth.user_authenticators"
"""
type authUserAuthenticators_aggregate_fields {
  avg: authUserAuthenticators_avg_fields
  count(columns: [authUserAuthenticators_select_column!], distinct: Boolean): Int!
  max: authUserAuthenticators_max_fields
  min: authUserAuthenticators_min_fields
  stddev: authUserAuthenticators_stddev_fields
  stddev_pop: authUserAuthenticators_stddev_pop_fields
  stddev_samp: authUserAuthenticators_stddev_samp_fields
  sum: authUserAuthenticators_sum_fields
  var_pop: authUserAuthenticators_var_pop_fields
  var_samp: authUserAuthenticators_var_samp_fields
  variance: authUserAuthenticators_variance_fields
}

"""
order by aggregate values of table "auth.user_authenticators"
"""
input authUserAuthenticators_aggregate_order_by {
  avg: authUserAuthenticators_avg_order_by
  count: order_by
  max: authUserAuthenticators_max_order_by
  min: authUserAuthenticators_min_order_by
  stddev: authUserAuthenticators_stddev_order_by
  stddev_pop: authUserAuthenticators_stddev_pop_order_by
  stddev_samp: authUserAuthenticators_stddev_samp_order_by
  sum: authUserAuthenticators_sum_order_by
  var_pop: authUserAuthenticators_var_pop_order_by
  var_samp: authUserAuthenticators_var_samp_order_by
  variance: authUserAuthenticators_variance_order_by
}

"""
input type for inserting array relation for remote table "auth.user_authenticators"
"""
input authUserAuthenticators_arr_rel_insert_input {
  data: [authUserAuthenticators_insert_input!]!

  """upsert condition"""
  on_conflict: authUserAuthenticators_on_conflict
}

"""aggregate avg on columns"""
type authUserAuthenticators_avg_fields {
  counter: Float
}

"""
order by avg() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_avg_order_by {
  counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_authenticators". All fields are combined with a logical 'AND'.
"""
input authUserAuthenticators_bool_exp {
  _and: [authUserAuthenticators_bool_exp!]
  _not: authUserAuthenticators_bool_exp
  _or: [authUserAuthenticators_bool_exp!]
  counter: bigint_comparison_exp
  credentialId: String_comparison_exp
  credentialPublicKey: bytea_comparison_exp
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  transports: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_authenticators"
"""
enum authUserAuthenticators_constraint {
  """
  unique or primary key constraint on columns "credential_id"
  """
  user_authenticators_credential_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_authenticators_pkey
}

"""
input type for incrementing numeric columns in table "auth.user_authenticators"
"""
input authUserAuthenticators_inc_input {
  counter: bigint
}

"""
input type for inserting data into table "auth.user_authenticators"
"""
input authUserAuthenticators_insert_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserAuthenticators_max_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_max_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserAuthenticators_min_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_min_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_authenticators"
"""
type authUserAuthenticators_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserAuthenticators!]!
}

"""
on_conflict condition type for table "auth.user_authenticators"
"""
input authUserAuthenticators_on_conflict {
  constraint: authUserAuthenticators_constraint!
  update_columns: [authUserAuthenticators_update_column!]! = []
  where: authUserAuthenticators_bool_exp
}

"""Ordering options when selecting data from "auth.user_authenticators"."""
input authUserAuthenticators_order_by {
  counter: order_by
  credentialId: order_by
  credentialPublicKey: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authUserAuthenticators"""
input authUserAuthenticators_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_authenticators"
"""
enum authUserAuthenticators_select_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_authenticators"
"""
input authUserAuthenticators_set_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate stddev on columns"""
type authUserAuthenticators_stddev_fields {
  counter: Float
}

"""
order by stddev() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_stddev_order_by {
  counter: order_by
}

"""aggregate stddev_pop on columns"""
type authUserAuthenticators_stddev_pop_fields {
  counter: Float
}

"""
order by stddev_pop() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_stddev_pop_order_by {
  counter: order_by
}

"""aggregate stddev_samp on columns"""
type authUserAuthenticators_stddev_samp_fields {
  counter: Float
}

"""
order by stddev_samp() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_stddev_samp_order_by {
  counter: order_by
}

"""aggregate sum on columns"""
type authUserAuthenticators_sum_fields {
  counter: bigint
}

"""
order by sum() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_sum_order_by {
  counter: order_by
}

"""
update columns of table "auth.user_authenticators"
"""
enum authUserAuthenticators_update_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

input authUserAuthenticators_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: authUserAuthenticators_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: authUserAuthenticators_set_input
  where: authUserAuthenticators_bool_exp!
}

"""aggregate var_pop on columns"""
type authUserAuthenticators_var_pop_fields {
  counter: Float
}

"""
order by var_pop() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_var_pop_order_by {
  counter: order_by
}

"""aggregate var_samp on columns"""
type authUserAuthenticators_var_samp_fields {
  counter: Float
}

"""
order by var_samp() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_var_samp_order_by {
  counter: order_by
}

"""aggregate variance on columns"""
type authUserAuthenticators_variance_fields {
  counter: Float
}

"""
order by variance() on columns of table "auth.user_authenticators"
"""
input authUserAuthenticators_variance_order_by {
  counter: order_by
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_providers_pkey

  """
  unique or primary key constraint on columns "provider_id", "provider_user_id"
  """
  user_providers_provider_id_provider_user_id_key

  """
  unique or primary key constraint on columns "provider_id", "user_id"
  """
  user_providers_user_id_provider_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authUserProviders"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input authUserProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserProviders_set_input
  where: authUserProviders_bool_exp!
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authUserRoles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

input authUserRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserRoles_set_input
  where: authUserRoles_bool_exp!
}

"""
Internal table for tracking migrations. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type auth_migrations {
  executed_at: timestamp
  hash: String!
  id: Int!
  name: String!
}

"""
aggregated selection of "auth.migrations"
"""
type auth_migrations_aggregate {
  aggregate: auth_migrations_aggregate_fields
  nodes: [auth_migrations!]!
}

"""
aggregate fields of "auth.migrations"
"""
type auth_migrations_aggregate_fields {
  avg: auth_migrations_avg_fields
  count(columns: [auth_migrations_select_column!], distinct: Boolean): Int!
  max: auth_migrations_max_fields
  min: auth_migrations_min_fields
  stddev: auth_migrations_stddev_fields
  stddev_pop: auth_migrations_stddev_pop_fields
  stddev_samp: auth_migrations_stddev_samp_fields
  sum: auth_migrations_sum_fields
  var_pop: auth_migrations_var_pop_fields
  var_samp: auth_migrations_var_samp_fields
  variance: auth_migrations_variance_fields
}

"""aggregate avg on columns"""
type auth_migrations_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "auth.migrations". All fields are combined with a logical 'AND'.
"""
input auth_migrations_bool_exp {
  _and: [auth_migrations_bool_exp!]
  _not: auth_migrations_bool_exp
  _or: [auth_migrations_bool_exp!]
  executed_at: timestamp_comparison_exp
  hash: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.migrations"
"""
enum auth_migrations_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  migrations_name_key

  """
  unique or primary key constraint on columns "id"
  """
  migrations_pkey
}

"""
input type for incrementing numeric columns in table "auth.migrations"
"""
input auth_migrations_inc_input {
  id: Int
}

"""
input type for inserting data into table "auth.migrations"
"""
input auth_migrations_insert_input {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate max on columns"""
type auth_migrations_max_fields {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate min on columns"""
type auth_migrations_min_fields {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""
response of any mutation on the table "auth.migrations"
"""
type auth_migrations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_migrations!]!
}

"""
on_conflict condition type for table "auth.migrations"
"""
input auth_migrations_on_conflict {
  constraint: auth_migrations_constraint!
  update_columns: [auth_migrations_update_column!]! = []
  where: auth_migrations_bool_exp
}

"""Ordering options when selecting data from "auth.migrations"."""
input auth_migrations_order_by {
  executed_at: order_by
  hash: order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: auth_migrations"""
input auth_migrations_pk_columns_input {
  id: Int!
}

"""
select columns of table "auth.migrations"
"""
enum auth_migrations_select_column {
  """column name"""
  executed_at

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "auth.migrations"
"""
input auth_migrations_set_input {
  executed_at: timestamp
  hash: String
  id: Int
  name: String
}

"""aggregate stddev on columns"""
type auth_migrations_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type auth_migrations_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type auth_migrations_stddev_samp_fields {
  id: Float
}

"""aggregate sum on columns"""
type auth_migrations_sum_fields {
  id: Int
}

"""
update columns of table "auth.migrations"
"""
enum auth_migrations_update_column {
  """column name"""
  executed_at

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  name
}

input auth_migrations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: auth_migrations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: auth_migrations_set_input
  where: auth_migrations_bool_exp!
}

"""aggregate var_pop on columns"""
type auth_migrations_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type auth_migrations_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type auth_migrations_variance_fields {
  id: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

input buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buckets_set_input
  where: buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""
columns and relationships of "en_notifications"
"""
type en_notifications {
  description: String!

  """An array relationship"""
  invites(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """An aggregate relationship"""
  invites_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!
  value: String!
}

"""
aggregated selection of "en_notifications"
"""
type en_notifications_aggregate {
  aggregate: en_notifications_aggregate_fields
  nodes: [en_notifications!]!
}

"""
aggregate fields of "en_notifications"
"""
type en_notifications_aggregate_fields {
  count(columns: [en_notifications_select_column!], distinct: Boolean): Int!
  max: en_notifications_max_fields
  min: en_notifications_min_fields
}

"""
Boolean expression to filter rows from the table "en_notifications". All fields are combined with a logical 'AND'.
"""
input en_notifications_bool_exp {
  _and: [en_notifications_bool_exp!]
  _not: en_notifications_bool_exp
  _or: [en_notifications_bool_exp!]
  description: String_comparison_exp
  invites: invitation_bool_exp
  notifications: notification_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "en_notifications"
"""
enum en_notifications_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  enum_notifications_pkey
}

enum en_notifications_enum {
  """Internal notification"""
  Internal

  """Whatsapp notification"""
  Whatsapp

  """Member invitation"""
  member_invitation

  """Member joined"""
  member_joined

  """Payment reminder"""
  payment_reminder

  """Payment Review"""
  payment_review

  """Period completion"""
  period_completion
}

"""
Boolean expression to compare columns of type "en_notifications_enum". All fields are combined with logical 'AND'.
"""
input en_notifications_enum_comparison_exp {
  _eq: en_notifications_enum
  _in: [en_notifications_enum!]
  _is_null: Boolean
  _neq: en_notifications_enum
  _nin: [en_notifications_enum!]
}

"""
input type for inserting data into table "en_notifications"
"""
input en_notifications_insert_input {
  description: String
  invites: invitation_arr_rel_insert_input
  notifications: notification_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type en_notifications_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type en_notifications_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "en_notifications"
"""
type en_notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [en_notifications!]!
}

"""
input type for inserting object relation for remote table "en_notifications"
"""
input en_notifications_obj_rel_insert_input {
  data: en_notifications_insert_input!

  """upsert condition"""
  on_conflict: en_notifications_on_conflict
}

"""
on_conflict condition type for table "en_notifications"
"""
input en_notifications_on_conflict {
  constraint: en_notifications_constraint!
  update_columns: [en_notifications_update_column!]! = []
  where: en_notifications_bool_exp
}

"""Ordering options when selecting data from "en_notifications"."""
input en_notifications_order_by {
  description: order_by
  invites_aggregate: invitation_aggregate_order_by
  notifications_aggregate: notification_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: en_notifications"""
input en_notifications_pk_columns_input {
  value: String!
}

"""
select columns of table "en_notifications"
"""
enum en_notifications_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "en_notifications"
"""
input en_notifications_set_input {
  description: String
  value: String
}

"""
update columns of table "en_notifications"
"""
enum en_notifications_update_column {
  """column name"""
  description

  """column name"""
  value
}

input en_notifications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: en_notifications_set_input
  where: en_notifications_bool_exp!
}

"""
columns and relationships of "en_permissions"
"""
type en_permissions {
  description: String!

  """An array relationship"""
  payment_permissions(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  payment_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!
  value: String!
}

"""
aggregated selection of "en_permissions"
"""
type en_permissions_aggregate {
  aggregate: en_permissions_aggregate_fields
  nodes: [en_permissions!]!
}

"""
aggregate fields of "en_permissions"
"""
type en_permissions_aggregate_fields {
  count(columns: [en_permissions_select_column!], distinct: Boolean): Int!
  max: en_permissions_max_fields
  min: en_permissions_min_fields
}

"""
Boolean expression to filter rows from the table "en_permissions". All fields are combined with a logical 'AND'.
"""
input en_permissions_bool_exp {
  _and: [en_permissions_bool_exp!]
  _not: en_permissions_bool_exp
  _or: [en_permissions_bool_exp!]
  description: String_comparison_exp
  payment_permissions: payment_review_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "en_permissions"
"""
enum en_permissions_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  en_permissions_pkey
}

enum en_permissions_enum {
  """Permission accepted"""
  Accepted

  """Response Pending"""
  Pending

  """Permission rejected"""
  Rejected
}

"""
Boolean expression to compare columns of type "en_permissions_enum". All fields are combined with logical 'AND'.
"""
input en_permissions_enum_comparison_exp {
  _eq: en_permissions_enum
  _in: [en_permissions_enum!]
  _is_null: Boolean
  _neq: en_permissions_enum
  _nin: [en_permissions_enum!]
}

"""
input type for inserting data into table "en_permissions"
"""
input en_permissions_insert_input {
  description: String
  payment_permissions: payment_review_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type en_permissions_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type en_permissions_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "en_permissions"
"""
type en_permissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [en_permissions!]!
}

"""
input type for inserting object relation for remote table "en_permissions"
"""
input en_permissions_obj_rel_insert_input {
  data: en_permissions_insert_input!

  """upsert condition"""
  on_conflict: en_permissions_on_conflict
}

"""
on_conflict condition type for table "en_permissions"
"""
input en_permissions_on_conflict {
  constraint: en_permissions_constraint!
  update_columns: [en_permissions_update_column!]! = []
  where: en_permissions_bool_exp
}

"""Ordering options when selecting data from "en_permissions"."""
input en_permissions_order_by {
  description: order_by
  payment_permissions_aggregate: payment_review_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: en_permissions"""
input en_permissions_pk_columns_input {
  value: String!
}

"""
select columns of table "en_permissions"
"""
enum en_permissions_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "en_permissions"
"""
input en_permissions_set_input {
  description: String
  value: String
}

"""
update columns of table "en_permissions"
"""
enum en_permissions_update_column {
  """column name"""
  description

  """column name"""
  value
}

input en_permissions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: en_permissions_set_input
  where: en_permissions_bool_exp!
}

"""
columns and relationships of "en_recurrencies"
"""
type en_recurrencies {
  description: String!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!
  value: String!
}

"""
aggregated selection of "en_recurrencies"
"""
type en_recurrencies_aggregate {
  aggregate: en_recurrencies_aggregate_fields
  nodes: [en_recurrencies!]!
}

"""
aggregate fields of "en_recurrencies"
"""
type en_recurrencies_aggregate_fields {
  count(columns: [en_recurrencies_select_column!], distinct: Boolean): Int!
  max: en_recurrencies_max_fields
  min: en_recurrencies_min_fields
}

"""
Boolean expression to filter rows from the table "en_recurrencies". All fields are combined with a logical 'AND'.
"""
input en_recurrencies_bool_exp {
  _and: [en_recurrencies_bool_exp!]
  _not: en_recurrencies_bool_exp
  _or: [en_recurrencies_bool_exp!]
  description: String_comparison_exp
  groups: group_bool_exp
  members: member_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "en_recurrencies"
"""
enum en_recurrencies_constraint {
  """
  unique or primary key constraint on columns "description"
  """
  enum_period_recurrency_description_key

  """
  unique or primary key constraint on columns "value"
  """
  enum_period_recurrency_pkey
}

enum en_recurrencies_enum {
  """Daily"""
  Daily

  """Monthly"""
  Monthly

  """Weekly"""
  Weekly
}

"""
Boolean expression to compare columns of type "en_recurrencies_enum". All fields are combined with logical 'AND'.
"""
input en_recurrencies_enum_comparison_exp {
  _eq: en_recurrencies_enum
  _in: [en_recurrencies_enum!]
  _is_null: Boolean
  _neq: en_recurrencies_enum
  _nin: [en_recurrencies_enum!]
}

"""
input type for inserting data into table "en_recurrencies"
"""
input en_recurrencies_insert_input {
  description: String
  groups: group_arr_rel_insert_input
  members: member_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type en_recurrencies_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type en_recurrencies_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "en_recurrencies"
"""
type en_recurrencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [en_recurrencies!]!
}

"""
input type for inserting object relation for remote table "en_recurrencies"
"""
input en_recurrencies_obj_rel_insert_input {
  data: en_recurrencies_insert_input!

  """upsert condition"""
  on_conflict: en_recurrencies_on_conflict
}

"""
on_conflict condition type for table "en_recurrencies"
"""
input en_recurrencies_on_conflict {
  constraint: en_recurrencies_constraint!
  update_columns: [en_recurrencies_update_column!]! = []
  where: en_recurrencies_bool_exp
}

"""Ordering options when selecting data from "en_recurrencies"."""
input en_recurrencies_order_by {
  description: order_by
  groups_aggregate: group_aggregate_order_by
  members_aggregate: member_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: en_recurrencies"""
input en_recurrencies_pk_columns_input {
  value: String!
}

"""
select columns of table "en_recurrencies"
"""
enum en_recurrencies_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "en_recurrencies"
"""
input en_recurrencies_set_input {
  description: String
  value: String
}

"""
update columns of table "en_recurrencies"
"""
enum en_recurrencies_update_column {
  """column name"""
  description

  """column name"""
  value
}

input en_recurrencies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: en_recurrencies_set_input
  where: en_recurrencies_bool_exp!
}

"""
columns and relationships of "en_statuses"
"""
type en_statuses {
  description: String!

  """An array relationship"""
  invites(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """An aggregate relationship"""
  invites_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!
  value: String!
}

"""
aggregated selection of "en_statuses"
"""
type en_statuses_aggregate {
  aggregate: en_statuses_aggregate_fields
  nodes: [en_statuses!]!
}

"""
aggregate fields of "en_statuses"
"""
type en_statuses_aggregate_fields {
  count(columns: [en_statuses_select_column!], distinct: Boolean): Int!
  max: en_statuses_max_fields
  min: en_statuses_min_fields
}

"""
Boolean expression to filter rows from the table "en_statuses". All fields are combined with a logical 'AND'.
"""
input en_statuses_bool_exp {
  _and: [en_statuses_bool_exp!]
  _not: en_statuses_bool_exp
  _or: [en_statuses_bool_exp!]
  description: String_comparison_exp
  invites: invitation_bool_exp
  notifications: notification_bool_exp
  payments: payment_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "en_statuses"
"""
enum en_statuses_constraint {
  """
  unique or primary key constraint on columns "description"
  """
  enum_statuses_description_key

  """
  unique or primary key constraint on columns "value"
  """
  enum_statuses_pkey
}

enum en_statuses_enum {
  """Cancelled"""
  Cancelled

  """Completed"""
  Completed

  """Failed"""
  Failed

  """Pending"""
  Pending

  """Processing"""
  Processing

  """Rejected"""
  Rejected
}

"""
Boolean expression to compare columns of type "en_statuses_enum". All fields are combined with logical 'AND'.
"""
input en_statuses_enum_comparison_exp {
  _eq: en_statuses_enum
  _in: [en_statuses_enum!]
  _is_null: Boolean
  _neq: en_statuses_enum
  _nin: [en_statuses_enum!]
}

"""
input type for inserting data into table "en_statuses"
"""
input en_statuses_insert_input {
  description: String
  invites: invitation_arr_rel_insert_input
  notifications: notification_arr_rel_insert_input
  payments: payment_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type en_statuses_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type en_statuses_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "en_statuses"
"""
type en_statuses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [en_statuses!]!
}

"""
input type for inserting object relation for remote table "en_statuses"
"""
input en_statuses_obj_rel_insert_input {
  data: en_statuses_insert_input!

  """upsert condition"""
  on_conflict: en_statuses_on_conflict
}

"""
on_conflict condition type for table "en_statuses"
"""
input en_statuses_on_conflict {
  constraint: en_statuses_constraint!
  update_columns: [en_statuses_update_column!]! = []
  where: en_statuses_bool_exp
}

"""Ordering options when selecting data from "en_statuses"."""
input en_statuses_order_by {
  description: order_by
  invites_aggregate: invitation_aggregate_order_by
  notifications_aggregate: notification_aggregate_order_by
  payments_aggregate: payment_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: en_statuses"""
input en_statuses_pk_columns_input {
  value: String!
}

"""
select columns of table "en_statuses"
"""
enum en_statuses_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "en_statuses"
"""
input en_statuses_set_input {
  description: String
  value: String
}

"""
update columns of table "en_statuses"
"""
enum en_statuses_update_column {
  """column name"""
  description

  """column name"""
  value
}

input en_statuses_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: en_statuses_set_input
  where: en_statuses_bool_exp!
}

"""
columns and relationships of "en_trans_types"
"""
type en_trans_types {
  description: String!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!
  value: String!
}

"""
aggregated selection of "en_trans_types"
"""
type en_trans_types_aggregate {
  aggregate: en_trans_types_aggregate_fields
  nodes: [en_trans_types!]!
}

"""
aggregate fields of "en_trans_types"
"""
type en_trans_types_aggregate_fields {
  count(columns: [en_trans_types_select_column!], distinct: Boolean): Int!
  max: en_trans_types_max_fields
  min: en_trans_types_min_fields
}

"""
Boolean expression to filter rows from the table "en_trans_types". All fields are combined with a logical 'AND'.
"""
input en_trans_types_bool_exp {
  _and: [en_trans_types_bool_exp!]
  _not: en_trans_types_bool_exp
  _or: [en_trans_types_bool_exp!]
  description: String_comparison_exp
  payments: payment_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "en_trans_types"
"""
enum en_trans_types_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  enum_trans_statuses_pkey
}

enum en_trans_types_enum {
  """Money in"""
  MoneyIn

  """Money out"""
  MoneyOut
}

"""
Boolean expression to compare columns of type "en_trans_types_enum". All fields are combined with logical 'AND'.
"""
input en_trans_types_enum_comparison_exp {
  _eq: en_trans_types_enum
  _in: [en_trans_types_enum!]
  _is_null: Boolean
  _neq: en_trans_types_enum
  _nin: [en_trans_types_enum!]
}

"""
input type for inserting data into table "en_trans_types"
"""
input en_trans_types_insert_input {
  description: String
  payments: payment_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type en_trans_types_max_fields {
  description: String
  value: String
}

"""aggregate min on columns"""
type en_trans_types_min_fields {
  description: String
  value: String
}

"""
response of any mutation on the table "en_trans_types"
"""
type en_trans_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [en_trans_types!]!
}

"""
input type for inserting object relation for remote table "en_trans_types"
"""
input en_trans_types_obj_rel_insert_input {
  data: en_trans_types_insert_input!

  """upsert condition"""
  on_conflict: en_trans_types_on_conflict
}

"""
on_conflict condition type for table "en_trans_types"
"""
input en_trans_types_on_conflict {
  constraint: en_trans_types_constraint!
  update_columns: [en_trans_types_update_column!]! = []
  where: en_trans_types_bool_exp
}

"""Ordering options when selecting data from "en_trans_types"."""
input en_trans_types_order_by {
  description: order_by
  payments_aggregate: payment_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: en_trans_types"""
input en_trans_types_pk_columns_input {
  value: String!
}

"""
select columns of table "en_trans_types"
"""
enum en_trans_types_select_column {
  """column name"""
  description

  """column name"""
  value
}

"""
input type for updating data in table "en_trans_types"
"""
input en_trans_types_set_input {
  description: String
  value: String
}

"""
update columns of table "en_trans_types"
"""
enum en_trans_types_update_column {
  """column name"""
  description

  """column name"""
  value
}

input en_trans_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: en_trans_types_set_input
  where: en_trans_types_bool_exp!
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

input files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

"""
columns and relationships of "group"
"""
type group {
  admin_id: uuid!
  contribution: numeric
  contribution_for_all: Boolean!
  created_at: timestamp!

  """An object relationship"""
  enum_recurrency: en_recurrencies

  """
  A computed field, executes function "group_balance"
  """
  group_balance: numeric
  group_name: String!
  id: uuid!

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """An aggregate relationship"""
  invitations_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!

  """An array relationship"""
  payment_reviews(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  payment_reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """An array relationship"""
  periods(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): [period!]!

  """An aggregate relationship"""
  periods_aggregate(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): period_aggregate!
  recurrency: en_recurrencies_enum
  recurrency_day: Int
  recurrency_for_all: Boolean!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
}

"""
aggregated selection of "group"
"""
type group_aggregate {
  aggregate: group_aggregate_fields
  nodes: [group!]!
}

"""
aggregate fields of "group"
"""
type group_aggregate_fields {
  avg: group_avg_fields
  count(columns: [group_select_column!], distinct: Boolean): Int!
  max: group_max_fields
  min: group_min_fields
  stddev: group_stddev_fields
  stddev_pop: group_stddev_pop_fields
  stddev_samp: group_stddev_samp_fields
  sum: group_sum_fields
  var_pop: group_var_pop_fields
  var_samp: group_var_samp_fields
  variance: group_variance_fields
}

"""
order by aggregate values of table "group"
"""
input group_aggregate_order_by {
  avg: group_avg_order_by
  count: order_by
  max: group_max_order_by
  min: group_min_order_by
  stddev: group_stddev_order_by
  stddev_pop: group_stddev_pop_order_by
  stddev_samp: group_stddev_samp_order_by
  sum: group_sum_order_by
  var_pop: group_var_pop_order_by
  var_samp: group_var_samp_order_by
  variance: group_variance_order_by
}

"""
input type for inserting array relation for remote table "group"
"""
input group_arr_rel_insert_input {
  data: [group_insert_input!]!

  """upsert condition"""
  on_conflict: group_on_conflict
}

"""aggregate avg on columns"""
type group_avg_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by avg() on columns of table "group"
"""
input group_avg_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""
Boolean expression to filter rows from the table "group". All fields are combined with a logical 'AND'.
"""
input group_bool_exp {
  _and: [group_bool_exp!]
  _not: group_bool_exp
  _or: [group_bool_exp!]
  admin_id: uuid_comparison_exp
  contribution: numeric_comparison_exp
  contribution_for_all: Boolean_comparison_exp
  created_at: timestamp_comparison_exp
  enum_recurrency: en_recurrencies_bool_exp
  group_balance: numeric_comparison_exp
  group_name: String_comparison_exp
  id: uuid_comparison_exp
  invitations: invitation_bool_exp
  members: member_bool_exp
  payment_reviews: payment_review_bool_exp
  payments: payment_bool_exp
  periods: period_bool_exp
  recurrency: en_recurrencies_enum_comparison_exp
  recurrency_day: Int_comparison_exp
  recurrency_for_all: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
}

"""
unique or primary key constraints on table "group"
"""
enum group_constraint {
  """
  unique or primary key constraint on columns "admin_id", "group_name"
  """
  group_admin_id_group_name_key

  """
  unique or primary key constraint on columns "id"
  """
  group_pkey
}

"""
input type for incrementing numeric columns in table "group"
"""
input group_inc_input {
  contribution: numeric
  recurrency_day: Int
}

"""
input type for inserting data into table "group"
"""
input group_insert_input {
  admin_id: uuid
  contribution: numeric
  contribution_for_all: Boolean
  created_at: timestamp
  enum_recurrency: en_recurrencies_obj_rel_insert_input
  group_name: String
  id: uuid
  invitations: invitation_arr_rel_insert_input
  members: member_arr_rel_insert_input
  payment_reviews: payment_review_arr_rel_insert_input
  payments: payment_arr_rel_insert_input
  periods: period_arr_rel_insert_input
  recurrency: en_recurrencies_enum
  recurrency_day: Int
  recurrency_for_all: Boolean
  updated_at: timestamptz
  user: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type group_max_fields {
  admin_id: uuid
  contribution: numeric
  created_at: timestamp
  group_name: String
  id: uuid
  recurrency_day: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "group"
"""
input group_max_order_by {
  admin_id: order_by
  contribution: order_by
  created_at: order_by
  group_name: order_by
  id: order_by
  recurrency_day: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type group_min_fields {
  admin_id: uuid
  contribution: numeric
  created_at: timestamp
  group_name: String
  id: uuid
  recurrency_day: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "group"
"""
input group_min_order_by {
  admin_id: order_by
  contribution: order_by
  created_at: order_by
  group_name: order_by
  id: order_by
  recurrency_day: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "group"
"""
type group_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [group!]!
}

"""
input type for inserting object relation for remote table "group"
"""
input group_obj_rel_insert_input {
  data: group_insert_input!

  """upsert condition"""
  on_conflict: group_on_conflict
}

"""
on_conflict condition type for table "group"
"""
input group_on_conflict {
  constraint: group_constraint!
  update_columns: [group_update_column!]! = []
  where: group_bool_exp
}

"""Ordering options when selecting data from "group"."""
input group_order_by {
  admin_id: order_by
  contribution: order_by
  contribution_for_all: order_by
  created_at: order_by
  enum_recurrency: en_recurrencies_order_by
  group_balance: order_by
  group_name: order_by
  id: order_by
  invitations_aggregate: invitation_aggregate_order_by
  members_aggregate: member_aggregate_order_by
  payment_reviews_aggregate: payment_review_aggregate_order_by
  payments_aggregate: payment_aggregate_order_by
  periods_aggregate: period_aggregate_order_by
  recurrency: order_by
  recurrency_day: order_by
  recurrency_for_all: order_by
  updated_at: order_by
  user: users_order_by
}

"""primary key columns input for table: group"""
input group_pk_columns_input {
  id: uuid!
}

"""
select columns of table "group"
"""
enum group_select_column {
  """column name"""
  admin_id

  """column name"""
  contribution

  """column name"""
  contribution_for_all

  """column name"""
  created_at

  """column name"""
  group_name

  """column name"""
  id

  """column name"""
  recurrency

  """column name"""
  recurrency_day

  """column name"""
  recurrency_for_all

  """column name"""
  updated_at
}

"""
input type for updating data in table "group"
"""
input group_set_input {
  admin_id: uuid
  contribution: numeric
  contribution_for_all: Boolean
  created_at: timestamp
  group_name: String
  id: uuid
  recurrency: en_recurrencies_enum
  recurrency_day: Int
  recurrency_for_all: Boolean
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type group_stddev_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by stddev() on columns of table "group"
"""
input group_stddev_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate stddev_pop on columns"""
type group_stddev_pop_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by stddev_pop() on columns of table "group"
"""
input group_stddev_pop_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate stddev_samp on columns"""
type group_stddev_samp_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by stddev_samp() on columns of table "group"
"""
input group_stddev_samp_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate sum on columns"""
type group_sum_fields {
  contribution: numeric
  recurrency_day: Int
}

"""
order by sum() on columns of table "group"
"""
input group_sum_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""
update columns of table "group"
"""
enum group_update_column {
  """column name"""
  admin_id

  """column name"""
  contribution

  """column name"""
  contribution_for_all

  """column name"""
  created_at

  """column name"""
  group_name

  """column name"""
  id

  """column name"""
  recurrency

  """column name"""
  recurrency_day

  """column name"""
  recurrency_for_all

  """column name"""
  updated_at
}

input group_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: group_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: group_set_input
  where: group_bool_exp!
}

"""aggregate var_pop on columns"""
type group_var_pop_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by var_pop() on columns of table "group"
"""
input group_var_pop_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate var_samp on columns"""
type group_var_samp_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by var_samp() on columns of table "group"
"""
input group_var_samp_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate variance on columns"""
type group_variance_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by variance() on columns of table "group"
"""
input group_variance_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""
columns and relationships of "invitation"
"""
type invitation {
  created_at: timestamptz!

  """An object relationship"""
  en_notification: en_notifications!

  """An object relationship"""
  en_status: en_statuses!

  """An object relationship"""
  group: group!
  group_id: uuid!
  id: uuid!
  invite_status: en_statuses_enum!
  invite_type: en_notifications_enum!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!
  receiver_id: uuid
  receiver_phone: String
  sender_id: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: users

  """An object relationship"""
  userBySenderId: users!
}

"""
aggregated selection of "invitation"
"""
type invitation_aggregate {
  aggregate: invitation_aggregate_fields
  nodes: [invitation!]!
}

"""
aggregate fields of "invitation"
"""
type invitation_aggregate_fields {
  count(columns: [invitation_select_column!], distinct: Boolean): Int!
  max: invitation_max_fields
  min: invitation_min_fields
}

"""
order by aggregate values of table "invitation"
"""
input invitation_aggregate_order_by {
  count: order_by
  max: invitation_max_order_by
  min: invitation_min_order_by
}

"""
input type for inserting array relation for remote table "invitation"
"""
input invitation_arr_rel_insert_input {
  data: [invitation_insert_input!]!

  """upsert condition"""
  on_conflict: invitation_on_conflict
}

"""
Boolean expression to filter rows from the table "invitation". All fields are combined with a logical 'AND'.
"""
input invitation_bool_exp {
  _and: [invitation_bool_exp!]
  _not: invitation_bool_exp
  _or: [invitation_bool_exp!]
  created_at: timestamptz_comparison_exp
  en_notification: en_notifications_bool_exp
  en_status: en_statuses_bool_exp
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  invite_status: en_statuses_enum_comparison_exp
  invite_type: en_notifications_enum_comparison_exp
  members: member_bool_exp
  notifications: notification_bool_exp
  receiver_id: uuid_comparison_exp
  receiver_phone: String_comparison_exp
  sender_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  userBySenderId: users_bool_exp
}

"""
unique or primary key constraints on table "invitation"
"""
enum invitation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  invite_pkey
}

"""
input type for inserting data into table "invitation"
"""
input invitation_insert_input {
  created_at: timestamptz
  en_notification: en_notifications_obj_rel_insert_input
  en_status: en_statuses_obj_rel_insert_input
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  invite_status: en_statuses_enum
  invite_type: en_notifications_enum
  members: member_arr_rel_insert_input
  notifications: notification_arr_rel_insert_input
  receiver_id: uuid
  receiver_phone: String
  sender_id: uuid
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  userBySenderId: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type invitation_max_fields {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  receiver_id: uuid
  receiver_phone: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "invitation"
"""
input invitation_max_order_by {
  created_at: order_by
  group_id: order_by
  id: order_by
  receiver_id: order_by
  receiver_phone: order_by
  sender_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type invitation_min_fields {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  receiver_id: uuid
  receiver_phone: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "invitation"
"""
input invitation_min_order_by {
  created_at: order_by
  group_id: order_by
  id: order_by
  receiver_id: order_by
  receiver_phone: order_by
  sender_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "invitation"
"""
type invitation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [invitation!]!
}

"""
input type for inserting object relation for remote table "invitation"
"""
input invitation_obj_rel_insert_input {
  data: invitation_insert_input!

  """upsert condition"""
  on_conflict: invitation_on_conflict
}

"""
on_conflict condition type for table "invitation"
"""
input invitation_on_conflict {
  constraint: invitation_constraint!
  update_columns: [invitation_update_column!]! = []
  where: invitation_bool_exp
}

"""Ordering options when selecting data from "invitation"."""
input invitation_order_by {
  created_at: order_by
  en_notification: en_notifications_order_by
  en_status: en_statuses_order_by
  group: group_order_by
  group_id: order_by
  id: order_by
  invite_status: order_by
  invite_type: order_by
  members_aggregate: member_aggregate_order_by
  notifications_aggregate: notification_aggregate_order_by
  receiver_id: order_by
  receiver_phone: order_by
  sender_id: order_by
  updated_at: order_by
  user: users_order_by
  userBySenderId: users_order_by
}

"""primary key columns input for table: invitation"""
input invitation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "invitation"
"""
enum invitation_select_column {
  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  invite_status

  """column name"""
  invite_type

  """column name"""
  receiver_id

  """column name"""
  receiver_phone

  """column name"""
  sender_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "invitation"
"""
input invitation_set_input {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  invite_status: en_statuses_enum
  invite_type: en_notifications_enum
  receiver_id: uuid
  receiver_phone: String
  sender_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "invitation"
"""
enum invitation_update_column {
  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  invite_status

  """column name"""
  invite_type

  """column name"""
  receiver_id

  """column name"""
  receiver_phone

  """column name"""
  sender_id

  """column name"""
  updated_at
}

input invitation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: invitation_set_input
  where: invitation_bool_exp!
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "member"
"""
type member {
  contribution: numeric!
  created_at: timestamptz!

  """An object relationship"""
  enum_recurrency: en_recurrencies!

  """
  A computed field, executes function "member_expense"
  """
  expense: numeric

  """An object relationship"""
  group: group!
  group_id: uuid!
  id: uuid!

  """
  A computed field, executes function "member_income"
  """
  income: numeric

  """An object relationship"""
  invitation: invitation
  invitation_id: uuid

  """An array relationship"""
  paymentReviewsByRequesterId(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  paymentReviewsByRequesterId_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!

  """An array relationship"""
  payment_reviews(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  payment_reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """An array relationship"""
  periods(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): [period!]!

  """An aggregate relationship"""
  periods_aggregate(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): period_aggregate!
  recurrency: en_recurrencies_enum!
  recurrency_day: Int
  reminder_days: String
  reminder_id: uuid
  reminder_next: timestamptz
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "member"
"""
type member_aggregate {
  aggregate: member_aggregate_fields
  nodes: [member!]!
}

"""
aggregate fields of "member"
"""
type member_aggregate_fields {
  avg: member_avg_fields
  count(columns: [member_select_column!], distinct: Boolean): Int!
  max: member_max_fields
  min: member_min_fields
  stddev: member_stddev_fields
  stddev_pop: member_stddev_pop_fields
  stddev_samp: member_stddev_samp_fields
  sum: member_sum_fields
  var_pop: member_var_pop_fields
  var_samp: member_var_samp_fields
  variance: member_variance_fields
}

"""
order by aggregate values of table "member"
"""
input member_aggregate_order_by {
  avg: member_avg_order_by
  count: order_by
  max: member_max_order_by
  min: member_min_order_by
  stddev: member_stddev_order_by
  stddev_pop: member_stddev_pop_order_by
  stddev_samp: member_stddev_samp_order_by
  sum: member_sum_order_by
  var_pop: member_var_pop_order_by
  var_samp: member_var_samp_order_by
  variance: member_variance_order_by
}

"""
input type for inserting array relation for remote table "member"
"""
input member_arr_rel_insert_input {
  data: [member_insert_input!]!

  """upsert condition"""
  on_conflict: member_on_conflict
}

"""aggregate avg on columns"""
type member_avg_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by avg() on columns of table "member"
"""
input member_avg_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""
Boolean expression to filter rows from the table "member". All fields are combined with a logical 'AND'.
"""
input member_bool_exp {
  _and: [member_bool_exp!]
  _not: member_bool_exp
  _or: [member_bool_exp!]
  contribution: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  enum_recurrency: en_recurrencies_bool_exp
  expense: numeric_comparison_exp
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  income: numeric_comparison_exp
  invitation: invitation_bool_exp
  invitation_id: uuid_comparison_exp
  paymentReviewsByRequesterId: payment_review_bool_exp
  payment_reviews: payment_review_bool_exp
  payments: payment_bool_exp
  periods: period_bool_exp
  recurrency: en_recurrencies_enum_comparison_exp
  recurrency_day: Int_comparison_exp
  reminder_days: String_comparison_exp
  reminder_id: uuid_comparison_exp
  reminder_next: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "member"
"""
enum member_constraint {
  """
  unique or primary key constraint on columns "group_id", "user_id"
  """
  member_group_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  member_pkey
}

"""
input type for incrementing numeric columns in table "member"
"""
input member_inc_input {
  contribution: numeric
  recurrency_day: Int
}

"""
input type for inserting data into table "member"
"""
input member_insert_input {
  contribution: numeric
  created_at: timestamptz
  enum_recurrency: en_recurrencies_obj_rel_insert_input
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  invitation: invitation_obj_rel_insert_input
  invitation_id: uuid
  paymentReviewsByRequesterId: payment_review_arr_rel_insert_input
  payment_reviews: payment_review_arr_rel_insert_input
  payments: payment_arr_rel_insert_input
  periods: period_arr_rel_insert_input
  recurrency: en_recurrencies_enum
  recurrency_day: Int
  reminder_days: String
  reminder_id: uuid
  reminder_next: timestamptz
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type member_max_fields {
  contribution: numeric
  created_at: timestamptz
  group_id: uuid
  id: uuid
  invitation_id: uuid
  recurrency_day: Int
  reminder_days: String
  reminder_id: uuid
  reminder_next: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "member"
"""
input member_max_order_by {
  contribution: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  invitation_id: order_by
  recurrency_day: order_by
  reminder_days: order_by
  reminder_id: order_by
  reminder_next: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type member_min_fields {
  contribution: numeric
  created_at: timestamptz
  group_id: uuid
  id: uuid
  invitation_id: uuid
  recurrency_day: Int
  reminder_days: String
  reminder_id: uuid
  reminder_next: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "member"
"""
input member_min_order_by {
  contribution: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  invitation_id: order_by
  recurrency_day: order_by
  reminder_days: order_by
  reminder_id: order_by
  reminder_next: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "member"
"""
type member_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [member!]!
}

"""
input type for inserting object relation for remote table "member"
"""
input member_obj_rel_insert_input {
  data: member_insert_input!

  """upsert condition"""
  on_conflict: member_on_conflict
}

"""
on_conflict condition type for table "member"
"""
input member_on_conflict {
  constraint: member_constraint!
  update_columns: [member_update_column!]! = []
  where: member_bool_exp
}

"""Ordering options when selecting data from "member"."""
input member_order_by {
  contribution: order_by
  created_at: order_by
  enum_recurrency: en_recurrencies_order_by
  expense: order_by
  group: group_order_by
  group_id: order_by
  id: order_by
  income: order_by
  invitation: invitation_order_by
  invitation_id: order_by
  paymentReviewsByRequesterId_aggregate: payment_review_aggregate_order_by
  payment_reviews_aggregate: payment_review_aggregate_order_by
  payments_aggregate: payment_aggregate_order_by
  periods_aggregate: period_aggregate_order_by
  recurrency: order_by
  recurrency_day: order_by
  reminder_days: order_by
  reminder_id: order_by
  reminder_next: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: member"""
input member_pk_columns_input {
  id: uuid!
}

"""
select columns of table "member"
"""
enum member_select_column {
  """column name"""
  contribution

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  invitation_id

  """column name"""
  recurrency

  """column name"""
  recurrency_day

  """column name"""
  reminder_days

  """column name"""
  reminder_id

  """column name"""
  reminder_next

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "member"
"""
input member_set_input {
  contribution: numeric
  created_at: timestamptz
  group_id: uuid
  id: uuid
  invitation_id: uuid
  recurrency: en_recurrencies_enum
  recurrency_day: Int
  reminder_days: String
  reminder_id: uuid
  reminder_next: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type member_stddev_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by stddev() on columns of table "member"
"""
input member_stddev_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate stddev_pop on columns"""
type member_stddev_pop_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by stddev_pop() on columns of table "member"
"""
input member_stddev_pop_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate stddev_samp on columns"""
type member_stddev_samp_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by stddev_samp() on columns of table "member"
"""
input member_stddev_samp_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate sum on columns"""
type member_sum_fields {
  contribution: numeric
  recurrency_day: Int
}

"""
order by sum() on columns of table "member"
"""
input member_sum_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""
update columns of table "member"
"""
enum member_update_column {
  """column name"""
  contribution

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  invitation_id

  """column name"""
  recurrency

  """column name"""
  recurrency_day

  """column name"""
  reminder_days

  """column name"""
  reminder_id

  """column name"""
  reminder_next

  """column name"""
  updated_at

  """column name"""
  user_id
}

input member_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: member_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: member_set_input
  where: member_bool_exp!
}

"""aggregate var_pop on columns"""
type member_var_pop_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by var_pop() on columns of table "member"
"""
input member_var_pop_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate var_samp on columns"""
type member_var_samp_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by var_samp() on columns of table "member"
"""
input member_var_samp_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""aggregate variance on columns"""
type member_variance_fields {
  contribution: Float
  recurrency_day: Float
}

"""
order by variance() on columns of table "member"
"""
input member_variance_order_by {
  contribution: order_by
  recurrency_day: order_by
}

"""mutation root"""
type mutation_root {
  complete_period(props: PeriodCompletionActionInput): PeriodCompletionActionOutput

  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_authenticators"
  """
  deleteAuthUserAuthenticator(id: uuid!): authUserAuthenticators

  """
  delete data from the table: "auth.user_authenticators"
  """
  deleteAuthUserAuthenticators(
    """filter the rows which have to be deleted"""
    where: authUserAuthenticators_bool_exp!
  ): authUserAuthenticators_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete data from the table: "auth.migrations"
  """
  delete_auth_migrations(
    """filter the rows which have to be deleted"""
    where: auth_migrations_bool_exp!
  ): auth_migrations_mutation_response

  """
  delete single row from the table: "auth.migrations"
  """
  delete_auth_migrations_by_pk(id: Int!): auth_migrations

  """
  delete data from the table: "en_notifications"
  """
  delete_en_notifications(
    """filter the rows which have to be deleted"""
    where: en_notifications_bool_exp!
  ): en_notifications_mutation_response

  """
  delete single row from the table: "en_notifications"
  """
  delete_en_notifications_by_pk(value: String!): en_notifications

  """
  delete data from the table: "en_permissions"
  """
  delete_en_permissions(
    """filter the rows which have to be deleted"""
    where: en_permissions_bool_exp!
  ): en_permissions_mutation_response

  """
  delete single row from the table: "en_permissions"
  """
  delete_en_permissions_by_pk(value: String!): en_permissions

  """
  delete data from the table: "en_recurrencies"
  """
  delete_en_recurrencies(
    """filter the rows which have to be deleted"""
    where: en_recurrencies_bool_exp!
  ): en_recurrencies_mutation_response

  """
  delete single row from the table: "en_recurrencies"
  """
  delete_en_recurrencies_by_pk(value: String!): en_recurrencies

  """
  delete data from the table: "en_statuses"
  """
  delete_en_statuses(
    """filter the rows which have to be deleted"""
    where: en_statuses_bool_exp!
  ): en_statuses_mutation_response

  """
  delete single row from the table: "en_statuses"
  """
  delete_en_statuses_by_pk(value: String!): en_statuses

  """
  delete data from the table: "en_trans_types"
  """
  delete_en_trans_types(
    """filter the rows which have to be deleted"""
    where: en_trans_types_bool_exp!
  ): en_trans_types_mutation_response

  """
  delete single row from the table: "en_trans_types"
  """
  delete_en_trans_types_by_pk(value: String!): en_trans_types

  """
  delete data from the table: "group"
  """
  delete_group(
    """filter the rows which have to be deleted"""
    where: group_bool_exp!
  ): group_mutation_response

  """
  delete single row from the table: "group"
  """
  delete_group_by_pk(id: uuid!): group

  """
  delete data from the table: "invitation"
  """
  delete_invitation(
    """filter the rows which have to be deleted"""
    where: invitation_bool_exp!
  ): invitation_mutation_response

  """
  delete single row from the table: "invitation"
  """
  delete_invitation_by_pk(id: uuid!): invitation

  """
  delete data from the table: "member"
  """
  delete_member(
    """filter the rows which have to be deleted"""
    where: member_bool_exp!
  ): member_mutation_response

  """
  delete single row from the table: "member"
  """
  delete_member_by_pk(id: uuid!): member

  """
  delete data from the table: "notification"
  """
  delete_notification(
    """filter the rows which have to be deleted"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  delete single row from the table: "notification"
  """
  delete_notification_by_pk(id: uuid!): notification

  """
  delete data from the table: "payment"
  """
  delete_payment(
    """filter the rows which have to be deleted"""
    where: payment_bool_exp!
  ): payment_mutation_response

  """
  delete single row from the table: "payment"
  """
  delete_payment_by_pk(id: uuid!): payment

  """
  delete data from the table: "payment_review"
  """
  delete_payment_review(
    """filter the rows which have to be deleted"""
    where: payment_review_bool_exp!
  ): payment_review_mutation_response

  """
  delete single row from the table: "payment_review"
  """
  delete_payment_review_by_pk(id: uuid!): payment_review

  """
  delete data from the table: "period"
  """
  delete_period(
    """filter the rows which have to be deleted"""
    where: period_bool_exp!
  ): period_mutation_response

  """
  delete single row from the table: "period"
  """
  delete_period_by_pk(id: uuid!): period

  """
  delete data from the table: "state_cache"
  """
  delete_state_cache(
    """filter the rows which have to be deleted"""
    where: state_cache_bool_exp!
  ): state_cache_mutation_response

  """
  delete single row from the table: "state_cache"
  """
  delete_state_cache_by_pk(id: uuid!): state_cache

  """
  delete data from the table: "user_profile"
  """
  delete_user_profile(
    """filter the rows which have to be deleted"""
    where: user_profile_bool_exp!
  ): user_profile_mutation_response

  """
  delete single row from the table: "user_profile"
  """
  delete_user_profile_by_pk(id: uuid!): user_profile

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_authenticators"
  """
  insertAuthUserAuthenticator(
    """the row to be inserted"""
    object: authUserAuthenticators_insert_input!

    """upsert condition"""
    on_conflict: authUserAuthenticators_on_conflict
  ): authUserAuthenticators

  """
  insert data into the table: "auth.user_authenticators"
  """
  insertAuthUserAuthenticators(
    """the rows to be inserted"""
    objects: [authUserAuthenticators_insert_input!]!

    """upsert condition"""
    on_conflict: authUserAuthenticators_on_conflict
  ): authUserAuthenticators_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert data into the table: "auth.migrations"
  """
  insert_auth_migrations(
    """the rows to be inserted"""
    objects: [auth_migrations_insert_input!]!

    """upsert condition"""
    on_conflict: auth_migrations_on_conflict
  ): auth_migrations_mutation_response

  """
  insert a single row into the table: "auth.migrations"
  """
  insert_auth_migrations_one(
    """the row to be inserted"""
    object: auth_migrations_insert_input!

    """upsert condition"""
    on_conflict: auth_migrations_on_conflict
  ): auth_migrations

  """
  insert data into the table: "en_notifications"
  """
  insert_en_notifications(
    """the rows to be inserted"""
    objects: [en_notifications_insert_input!]!

    """upsert condition"""
    on_conflict: en_notifications_on_conflict
  ): en_notifications_mutation_response

  """
  insert a single row into the table: "en_notifications"
  """
  insert_en_notifications_one(
    """the row to be inserted"""
    object: en_notifications_insert_input!

    """upsert condition"""
    on_conflict: en_notifications_on_conflict
  ): en_notifications

  """
  insert data into the table: "en_permissions"
  """
  insert_en_permissions(
    """the rows to be inserted"""
    objects: [en_permissions_insert_input!]!

    """upsert condition"""
    on_conflict: en_permissions_on_conflict
  ): en_permissions_mutation_response

  """
  insert a single row into the table: "en_permissions"
  """
  insert_en_permissions_one(
    """the row to be inserted"""
    object: en_permissions_insert_input!

    """upsert condition"""
    on_conflict: en_permissions_on_conflict
  ): en_permissions

  """
  insert data into the table: "en_recurrencies"
  """
  insert_en_recurrencies(
    """the rows to be inserted"""
    objects: [en_recurrencies_insert_input!]!

    """upsert condition"""
    on_conflict: en_recurrencies_on_conflict
  ): en_recurrencies_mutation_response

  """
  insert a single row into the table: "en_recurrencies"
  """
  insert_en_recurrencies_one(
    """the row to be inserted"""
    object: en_recurrencies_insert_input!

    """upsert condition"""
    on_conflict: en_recurrencies_on_conflict
  ): en_recurrencies

  """
  insert data into the table: "en_statuses"
  """
  insert_en_statuses(
    """the rows to be inserted"""
    objects: [en_statuses_insert_input!]!

    """upsert condition"""
    on_conflict: en_statuses_on_conflict
  ): en_statuses_mutation_response

  """
  insert a single row into the table: "en_statuses"
  """
  insert_en_statuses_one(
    """the row to be inserted"""
    object: en_statuses_insert_input!

    """upsert condition"""
    on_conflict: en_statuses_on_conflict
  ): en_statuses

  """
  insert data into the table: "en_trans_types"
  """
  insert_en_trans_types(
    """the rows to be inserted"""
    objects: [en_trans_types_insert_input!]!

    """upsert condition"""
    on_conflict: en_trans_types_on_conflict
  ): en_trans_types_mutation_response

  """
  insert a single row into the table: "en_trans_types"
  """
  insert_en_trans_types_one(
    """the row to be inserted"""
    object: en_trans_types_insert_input!

    """upsert condition"""
    on_conflict: en_trans_types_on_conflict
  ): en_trans_types

  """
  insert data into the table: "group"
  """
  insert_group(
    """the rows to be inserted"""
    objects: [group_insert_input!]!

    """upsert condition"""
    on_conflict: group_on_conflict
  ): group_mutation_response

  """
  insert a single row into the table: "group"
  """
  insert_group_one(
    """the row to be inserted"""
    object: group_insert_input!

    """upsert condition"""
    on_conflict: group_on_conflict
  ): group

  """
  insert data into the table: "invitation"
  """
  insert_invitation(
    """the rows to be inserted"""
    objects: [invitation_insert_input!]!

    """upsert condition"""
    on_conflict: invitation_on_conflict
  ): invitation_mutation_response

  """
  insert a single row into the table: "invitation"
  """
  insert_invitation_one(
    """the row to be inserted"""
    object: invitation_insert_input!

    """upsert condition"""
    on_conflict: invitation_on_conflict
  ): invitation

  """
  insert data into the table: "member"
  """
  insert_member(
    """the rows to be inserted"""
    objects: [member_insert_input!]!

    """upsert condition"""
    on_conflict: member_on_conflict
  ): member_mutation_response

  """
  insert a single row into the table: "member"
  """
  insert_member_one(
    """the row to be inserted"""
    object: member_insert_input!

    """upsert condition"""
    on_conflict: member_on_conflict
  ): member

  """
  insert data into the table: "notification"
  """
  insert_notification(
    """the rows to be inserted"""
    objects: [notification_insert_input!]!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  """
  insert a single row into the table: "notification"
  """
  insert_notification_one(
    """the row to be inserted"""
    object: notification_insert_input!

    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification

  """
  insert data into the table: "payment"
  """
  insert_payment(
    """the rows to be inserted"""
    objects: [payment_insert_input!]!

    """upsert condition"""
    on_conflict: payment_on_conflict
  ): payment_mutation_response

  """
  insert a single row into the table: "payment"
  """
  insert_payment_one(
    """the row to be inserted"""
    object: payment_insert_input!

    """upsert condition"""
    on_conflict: payment_on_conflict
  ): payment

  """
  insert data into the table: "payment_review"
  """
  insert_payment_review(
    """the rows to be inserted"""
    objects: [payment_review_insert_input!]!

    """upsert condition"""
    on_conflict: payment_review_on_conflict
  ): payment_review_mutation_response

  """
  insert a single row into the table: "payment_review"
  """
  insert_payment_review_one(
    """the row to be inserted"""
    object: payment_review_insert_input!

    """upsert condition"""
    on_conflict: payment_review_on_conflict
  ): payment_review

  """
  insert data into the table: "period"
  """
  insert_period(
    """the rows to be inserted"""
    objects: [period_insert_input!]!

    """upsert condition"""
    on_conflict: period_on_conflict
  ): period_mutation_response

  """
  insert a single row into the table: "period"
  """
  insert_period_one(
    """the row to be inserted"""
    object: period_insert_input!

    """upsert condition"""
    on_conflict: period_on_conflict
  ): period

  """
  insert data into the table: "state_cache"
  """
  insert_state_cache(
    """the rows to be inserted"""
    objects: [state_cache_insert_input!]!

    """upsert condition"""
    on_conflict: state_cache_on_conflict
  ): state_cache_mutation_response

  """
  insert a single row into the table: "state_cache"
  """
  insert_state_cache_one(
    """the row to be inserted"""
    object: state_cache_insert_input!

    """upsert condition"""
    on_conflict: state_cache_on_conflict
  ): state_cache

  """
  insert data into the table: "user_profile"
  """
  insert_user_profile(
    """the rows to be inserted"""
    objects: [user_profile_insert_input!]!

    """upsert condition"""
    on_conflict: user_profile_on_conflict
  ): user_profile_mutation_response

  """
  insert a single row into the table: "user_profile"
  """
  insert_user_profile_one(
    """the row to be inserted"""
    object: user_profile_insert_input!

    """upsert condition"""
    on_conflict: user_profile_on_conflict
  ): user_profile
  invite_member(arg: InviteInput!): InviteOutput
  request_balances(input: [CURRENCY]): [Balance]
  send_message(arg: TestMessageInput!): TestMessageOutput

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_authenticators"
  """
  updateAuthUserAuthenticator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserAuthenticators_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserAuthenticators_set_input
    pk_columns: authUserAuthenticators_pk_columns_input!
  ): authUserAuthenticators

  """
  update data of the table: "auth.user_authenticators"
  """
  updateAuthUserAuthenticators(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserAuthenticators_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserAuthenticators_set_input

    """filter the rows which have to be updated"""
    where: authUserAuthenticators_bool_exp!
  ): authUserAuthenticators_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update multiples rows of table: "auth.provider_requests"
  """
  update_authProviderRequests_many(
    """updates to execute, in order"""
    updates: [authProviderRequests_updates!]!
  ): [authProviderRequests_mutation_response]

  """
  update multiples rows of table: "auth.providers"
  """
  update_authProviders_many(
    """updates to execute, in order"""
    updates: [authProviders_updates!]!
  ): [authProviders_mutation_response]

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_authRefreshTokens_many(
    """updates to execute, in order"""
    updates: [authRefreshTokens_updates!]!
  ): [authRefreshTokens_mutation_response]

  """
  update multiples rows of table: "auth.roles"
  """
  update_authRoles_many(
    """updates to execute, in order"""
    updates: [authRoles_updates!]!
  ): [authRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_authenticators"
  """
  update_authUserAuthenticators_many(
    """updates to execute, in order"""
    updates: [authUserAuthenticators_updates!]!
  ): [authUserAuthenticators_mutation_response]

  """
  update multiples rows of table: "auth.user_providers"
  """
  update_authUserProviders_many(
    """updates to execute, in order"""
    updates: [authUserProviders_updates!]!
  ): [authUserProviders_mutation_response]

  """
  update multiples rows of table: "auth.user_roles"
  """
  update_authUserRoles_many(
    """updates to execute, in order"""
    updates: [authUserRoles_updates!]!
  ): [authUserRoles_mutation_response]

  """
  update data of the table: "auth.migrations"
  """
  update_auth_migrations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_migrations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_migrations_set_input

    """filter the rows which have to be updated"""
    where: auth_migrations_bool_exp!
  ): auth_migrations_mutation_response

  """
  update single row of the table: "auth.migrations"
  """
  update_auth_migrations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auth_migrations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_migrations_set_input
    pk_columns: auth_migrations_pk_columns_input!
  ): auth_migrations

  """
  update multiples rows of table: "auth.migrations"
  """
  update_auth_migrations_many(
    """updates to execute, in order"""
    updates: [auth_migrations_updates!]!
  ): [auth_migrations_mutation_response]

  """
  update multiples rows of table: "storage.buckets"
  """
  update_buckets_many(
    """updates to execute, in order"""
    updates: [buckets_updates!]!
  ): [buckets_mutation_response]

  """
  update data of the table: "en_notifications"
  """
  update_en_notifications(
    """sets the columns of the filtered rows to the given values"""
    _set: en_notifications_set_input

    """filter the rows which have to be updated"""
    where: en_notifications_bool_exp!
  ): en_notifications_mutation_response

  """
  update single row of the table: "en_notifications"
  """
  update_en_notifications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: en_notifications_set_input
    pk_columns: en_notifications_pk_columns_input!
  ): en_notifications

  """
  update multiples rows of table: "en_notifications"
  """
  update_en_notifications_many(
    """updates to execute, in order"""
    updates: [en_notifications_updates!]!
  ): [en_notifications_mutation_response]

  """
  update data of the table: "en_permissions"
  """
  update_en_permissions(
    """sets the columns of the filtered rows to the given values"""
    _set: en_permissions_set_input

    """filter the rows which have to be updated"""
    where: en_permissions_bool_exp!
  ): en_permissions_mutation_response

  """
  update single row of the table: "en_permissions"
  """
  update_en_permissions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: en_permissions_set_input
    pk_columns: en_permissions_pk_columns_input!
  ): en_permissions

  """
  update multiples rows of table: "en_permissions"
  """
  update_en_permissions_many(
    """updates to execute, in order"""
    updates: [en_permissions_updates!]!
  ): [en_permissions_mutation_response]

  """
  update data of the table: "en_recurrencies"
  """
  update_en_recurrencies(
    """sets the columns of the filtered rows to the given values"""
    _set: en_recurrencies_set_input

    """filter the rows which have to be updated"""
    where: en_recurrencies_bool_exp!
  ): en_recurrencies_mutation_response

  """
  update single row of the table: "en_recurrencies"
  """
  update_en_recurrencies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: en_recurrencies_set_input
    pk_columns: en_recurrencies_pk_columns_input!
  ): en_recurrencies

  """
  update multiples rows of table: "en_recurrencies"
  """
  update_en_recurrencies_many(
    """updates to execute, in order"""
    updates: [en_recurrencies_updates!]!
  ): [en_recurrencies_mutation_response]

  """
  update data of the table: "en_statuses"
  """
  update_en_statuses(
    """sets the columns of the filtered rows to the given values"""
    _set: en_statuses_set_input

    """filter the rows which have to be updated"""
    where: en_statuses_bool_exp!
  ): en_statuses_mutation_response

  """
  update single row of the table: "en_statuses"
  """
  update_en_statuses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: en_statuses_set_input
    pk_columns: en_statuses_pk_columns_input!
  ): en_statuses

  """
  update multiples rows of table: "en_statuses"
  """
  update_en_statuses_many(
    """updates to execute, in order"""
    updates: [en_statuses_updates!]!
  ): [en_statuses_mutation_response]

  """
  update data of the table: "en_trans_types"
  """
  update_en_trans_types(
    """sets the columns of the filtered rows to the given values"""
    _set: en_trans_types_set_input

    """filter the rows which have to be updated"""
    where: en_trans_types_bool_exp!
  ): en_trans_types_mutation_response

  """
  update single row of the table: "en_trans_types"
  """
  update_en_trans_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: en_trans_types_set_input
    pk_columns: en_trans_types_pk_columns_input!
  ): en_trans_types

  """
  update multiples rows of table: "en_trans_types"
  """
  update_en_trans_types_many(
    """updates to execute, in order"""
    updates: [en_trans_types_updates!]!
  ): [en_trans_types_mutation_response]

  """
  update multiples rows of table: "storage.files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "group"
  """
  update_group(
    """increments the numeric columns with given value of the filtered values"""
    _inc: group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: group_set_input

    """filter the rows which have to be updated"""
    where: group_bool_exp!
  ): group_mutation_response

  """
  update single row of the table: "group"
  """
  update_group_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: group_set_input
    pk_columns: group_pk_columns_input!
  ): group

  """
  update multiples rows of table: "group"
  """
  update_group_many(
    """updates to execute, in order"""
    updates: [group_updates!]!
  ): [group_mutation_response]

  """
  update data of the table: "invitation"
  """
  update_invitation(
    """sets the columns of the filtered rows to the given values"""
    _set: invitation_set_input

    """filter the rows which have to be updated"""
    where: invitation_bool_exp!
  ): invitation_mutation_response

  """
  update single row of the table: "invitation"
  """
  update_invitation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: invitation_set_input
    pk_columns: invitation_pk_columns_input!
  ): invitation

  """
  update multiples rows of table: "invitation"
  """
  update_invitation_many(
    """updates to execute, in order"""
    updates: [invitation_updates!]!
  ): [invitation_mutation_response]

  """
  update data of the table: "member"
  """
  update_member(
    """increments the numeric columns with given value of the filtered values"""
    _inc: member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: member_set_input

    """filter the rows which have to be updated"""
    where: member_bool_exp!
  ): member_mutation_response

  """
  update single row of the table: "member"
  """
  update_member_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: member_set_input
    pk_columns: member_pk_columns_input!
  ): member

  """
  update multiples rows of table: "member"
  """
  update_member_many(
    """updates to execute, in order"""
    updates: [member_updates!]!
  ): [member_mutation_response]

  """
  update data of the table: "notification"
  """
  update_notification(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input

    """filter the rows which have to be updated"""
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  update single row of the table: "notification"
  """
  update_notification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  """
  update multiples rows of table: "notification"
  """
  update_notification_many(
    """updates to execute, in order"""
    updates: [notification_updates!]!
  ): [notification_mutation_response]

  """
  update data of the table: "payment"
  """
  update_payment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_set_input

    """filter the rows which have to be updated"""
    where: payment_bool_exp!
  ): payment_mutation_response

  """
  update single row of the table: "payment"
  """
  update_payment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_set_input
    pk_columns: payment_pk_columns_input!
  ): payment

  """
  update multiples rows of table: "payment"
  """
  update_payment_many(
    """updates to execute, in order"""
    updates: [payment_updates!]!
  ): [payment_mutation_response]

  """
  update data of the table: "payment_review"
  """
  update_payment_review(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_review_set_input

    """filter the rows which have to be updated"""
    where: payment_review_bool_exp!
  ): payment_review_mutation_response

  """
  update single row of the table: "payment_review"
  """
  update_payment_review_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_review_set_input
    pk_columns: payment_review_pk_columns_input!
  ): payment_review

  """
  update multiples rows of table: "payment_review"
  """
  update_payment_review_many(
    """updates to execute, in order"""
    updates: [payment_review_updates!]!
  ): [payment_review_mutation_response]

  """
  update data of the table: "period"
  """
  update_period(
    """increments the numeric columns with given value of the filtered values"""
    _inc: period_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: period_set_input

    """filter the rows which have to be updated"""
    where: period_bool_exp!
  ): period_mutation_response

  """
  update single row of the table: "period"
  """
  update_period_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: period_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: period_set_input
    pk_columns: period_pk_columns_input!
  ): period

  """
  update multiples rows of table: "period"
  """
  update_period_many(
    """updates to execute, in order"""
    updates: [period_updates!]!
  ): [period_mutation_response]

  """
  update data of the table: "state_cache"
  """
  update_state_cache(
    """sets the columns of the filtered rows to the given values"""
    _set: state_cache_set_input

    """filter the rows which have to be updated"""
    where: state_cache_bool_exp!
  ): state_cache_mutation_response

  """
  update single row of the table: "state_cache"
  """
  update_state_cache_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: state_cache_set_input
    pk_columns: state_cache_pk_columns_input!
  ): state_cache

  """
  update multiples rows of table: "state_cache"
  """
  update_state_cache_many(
    """updates to execute, in order"""
    updates: [state_cache_updates!]!
  ): [state_cache_mutation_response]

  """
  update data of the table: "user_profile"
  """
  update_user_profile(
    """sets the columns of the filtered rows to the given values"""
    _set: user_profile_set_input

    """filter the rows which have to be updated"""
    where: user_profile_bool_exp!
  ): user_profile_mutation_response

  """
  update single row of the table: "user_profile"
  """
  update_user_profile_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_profile_set_input
    pk_columns: user_profile_pk_columns_input!
  ): user_profile

  """
  update multiples rows of table: "user_profile"
  """
  update_user_profile_many(
    """updates to execute, in order"""
    updates: [user_profile_updates!]!
  ): [user_profile_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]
}

"""
columns and relationships of "notification"
"""
type notification {
  created_at: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): json

  """An object relationship"""
  en_notification: en_notifications!

  """An object relationship"""
  en_status: en_statuses
  id: uuid!

  """An object relationship"""
  invitation: invitation
  invitation_id: uuid
  is_viewed: Boolean
  message: String!
  notifiable: Boolean
  payment_review_id: uuid

  """An object relationship"""
  payment_reviews: payment_review

  """An object relationship"""
  period: period
  period_id: uuid
  status: en_statuses_enum
  title: String
  type: en_notifications_enum!
  updated_at: timestamptz!

  """An object relationship"""
  user: users
  user_id: uuid
}

"""
aggregated selection of "notification"
"""
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

"""
aggregate fields of "notification"
"""
type notification_aggregate_fields {
  count(columns: [notification_select_column!], distinct: Boolean): Int!
  max: notification_max_fields
  min: notification_min_fields
}

"""
order by aggregate values of table "notification"
"""
input notification_aggregate_order_by {
  count: order_by
  max: notification_max_order_by
  min: notification_min_order_by
}

"""
input type for inserting array relation for remote table "notification"
"""
input notification_arr_rel_insert_input {
  data: [notification_insert_input!]!

  """upsert condition"""
  on_conflict: notification_on_conflict
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp!]
  _not: notification_bool_exp
  _or: [notification_bool_exp!]
  created_at: timestamptz_comparison_exp
  data: json_comparison_exp
  en_notification: en_notifications_bool_exp
  en_status: en_statuses_bool_exp
  id: uuid_comparison_exp
  invitation: invitation_bool_exp
  invitation_id: uuid_comparison_exp
  is_viewed: Boolean_comparison_exp
  message: String_comparison_exp
  notifiable: Boolean_comparison_exp
  payment_review_id: uuid_comparison_exp
  payment_reviews: payment_review_bool_exp
  period: period_bool_exp
  period_id: uuid_comparison_exp
  status: en_statuses_enum_comparison_exp
  title: String_comparison_exp
  type: en_notifications_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
input type for inserting data into table "notification"
"""
input notification_insert_input {
  created_at: timestamptz
  data: json
  en_notification: en_notifications_obj_rel_insert_input
  en_status: en_statuses_obj_rel_insert_input
  id: uuid
  invitation: invitation_obj_rel_insert_input
  invitation_id: uuid
  is_viewed: Boolean
  message: String
  notifiable: Boolean
  payment_review_id: uuid
  payment_reviews: payment_review_obj_rel_insert_input
  period: period_obj_rel_insert_input
  period_id: uuid
  status: en_statuses_enum
  title: String
  type: en_notifications_enum
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type notification_max_fields {
  created_at: timestamptz
  id: uuid
  invitation_id: uuid
  message: String
  payment_review_id: uuid
  period_id: uuid
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "notification"
"""
input notification_max_order_by {
  created_at: order_by
  id: order_by
  invitation_id: order_by
  message: order_by
  payment_review_id: order_by
  period_id: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type notification_min_fields {
  created_at: timestamptz
  id: uuid
  invitation_id: uuid
  message: String
  payment_review_id: uuid
  period_id: uuid
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "notification"
"""
input notification_min_order_by {
  created_at: order_by
  id: order_by
  invitation_id: order_by
  message: order_by
  payment_review_id: order_by
  period_id: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "notification"
"""
type notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notification!]!
}

"""
on_conflict condition type for table "notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]! = []
  where: notification_bool_exp
}

"""Ordering options when selecting data from "notification"."""
input notification_order_by {
  created_at: order_by
  data: order_by
  en_notification: en_notifications_order_by
  en_status: en_statuses_order_by
  id: order_by
  invitation: invitation_order_by
  invitation_id: order_by
  is_viewed: order_by
  message: order_by
  notifiable: order_by
  payment_review_id: order_by
  payment_reviews: payment_review_order_by
  period: period_order_by
  period_id: order_by
  status: order_by
  title: order_by
  type: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: notification"""
input notification_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notification"
"""
enum notification_select_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  id

  """column name"""
  invitation_id

  """column name"""
  is_viewed

  """column name"""
  message

  """column name"""
  notifiable

  """column name"""
  payment_review_id

  """column name"""
  period_id

  """column name"""
  status

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "notification"
"""
input notification_set_input {
  created_at: timestamptz
  data: json
  id: uuid
  invitation_id: uuid
  is_viewed: Boolean
  message: String
  notifiable: Boolean
  payment_review_id: uuid
  period_id: uuid
  status: en_statuses_enum
  title: String
  type: en_notifications_enum
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "notification"
"""
enum notification_update_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  id

  """column name"""
  invitation_id

  """column name"""
  is_viewed

  """column name"""
  message

  """column name"""
  notifiable

  """column name"""
  payment_review_id

  """column name"""
  period_id

  """column name"""
  status

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

input notification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notification_set_input
  where: notification_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "payment"
"""
type payment {
  amount: numeric!
  created_at: timestamptz!

  """An object relationship"""
  enum_status: en_statuses!

  """An object relationship"""
  enum_trans_type: en_trans_types!

  """An object relationship"""
  group: group!
  group_id: uuid!
  id: uuid!

  """An object relationship"""
  member: member!
  member_id: uuid!
  narration: String

  """An array relationship"""
  paymentReviewsByPaymentId(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  paymentReviewsByPaymentId_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!
  payment_currency: String
  payment_response_code: String

  """An array relationship"""
  payment_reviews(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  payment_reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!
  payment_state: String
  payment_url: String

  """An object relationship"""
  period: period!
  period_id: uuid!
  recipient_name: String
  recipient_phone: String
  transaction_status: en_statuses_enum!
  transaction_type: en_trans_types_enum!
  updated_at: timestamptz!
}

"""
aggregated selection of "payment"
"""
type payment_aggregate {
  aggregate: payment_aggregate_fields
  nodes: [payment!]!
}

"""
aggregate fields of "payment"
"""
type payment_aggregate_fields {
  avg: payment_avg_fields
  count(columns: [payment_select_column!], distinct: Boolean): Int!
  max: payment_max_fields
  min: payment_min_fields
  stddev: payment_stddev_fields
  stddev_pop: payment_stddev_pop_fields
  stddev_samp: payment_stddev_samp_fields
  sum: payment_sum_fields
  var_pop: payment_var_pop_fields
  var_samp: payment_var_samp_fields
  variance: payment_variance_fields
}

"""
order by aggregate values of table "payment"
"""
input payment_aggregate_order_by {
  avg: payment_avg_order_by
  count: order_by
  max: payment_max_order_by
  min: payment_min_order_by
  stddev: payment_stddev_order_by
  stddev_pop: payment_stddev_pop_order_by
  stddev_samp: payment_stddev_samp_order_by
  sum: payment_sum_order_by
  var_pop: payment_var_pop_order_by
  var_samp: payment_var_samp_order_by
  variance: payment_variance_order_by
}

"""
input type for inserting array relation for remote table "payment"
"""
input payment_arr_rel_insert_input {
  data: [payment_insert_input!]!

  """upsert condition"""
  on_conflict: payment_on_conflict
}

"""aggregate avg on columns"""
type payment_avg_fields {
  amount: Float
}

"""
order by avg() on columns of table "payment"
"""
input payment_avg_order_by {
  amount: order_by
}

"""
Boolean expression to filter rows from the table "payment". All fields are combined with a logical 'AND'.
"""
input payment_bool_exp {
  _and: [payment_bool_exp!]
  _not: payment_bool_exp
  _or: [payment_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  enum_status: en_statuses_bool_exp
  enum_trans_type: en_trans_types_bool_exp
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  member: member_bool_exp
  member_id: uuid_comparison_exp
  narration: String_comparison_exp
  paymentReviewsByPaymentId: payment_review_bool_exp
  payment_currency: String_comparison_exp
  payment_response_code: String_comparison_exp
  payment_reviews: payment_review_bool_exp
  payment_state: String_comparison_exp
  payment_url: String_comparison_exp
  period: period_bool_exp
  period_id: uuid_comparison_exp
  recipient_name: String_comparison_exp
  recipient_phone: String_comparison_exp
  transaction_status: en_statuses_enum_comparison_exp
  transaction_type: en_trans_types_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payment"
"""
enum payment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_pkey
}

"""
input type for incrementing numeric columns in table "payment"
"""
input payment_inc_input {
  amount: numeric
}

"""
input type for inserting data into table "payment"
"""
input payment_insert_input {
  amount: numeric
  created_at: timestamptz
  enum_status: en_statuses_obj_rel_insert_input
  enum_trans_type: en_trans_types_obj_rel_insert_input
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  member: member_obj_rel_insert_input
  member_id: uuid
  narration: String
  paymentReviewsByPaymentId: payment_review_arr_rel_insert_input
  payment_currency: String
  payment_response_code: String
  payment_reviews: payment_review_arr_rel_insert_input
  payment_state: String
  payment_url: String
  period: period_obj_rel_insert_input
  period_id: uuid
  recipient_name: String
  recipient_phone: String
  transaction_status: en_statuses_enum
  transaction_type: en_trans_types_enum
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payment_max_fields {
  amount: numeric
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  narration: String
  payment_currency: String
  payment_response_code: String
  payment_state: String
  payment_url: String
  period_id: uuid
  recipient_name: String
  recipient_phone: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "payment"
"""
input payment_max_order_by {
  amount: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  member_id: order_by
  narration: order_by
  payment_currency: order_by
  payment_response_code: order_by
  payment_state: order_by
  payment_url: order_by
  period_id: order_by
  recipient_name: order_by
  recipient_phone: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type payment_min_fields {
  amount: numeric
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  narration: String
  payment_currency: String
  payment_response_code: String
  payment_state: String
  payment_url: String
  period_id: uuid
  recipient_name: String
  recipient_phone: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "payment"
"""
input payment_min_order_by {
  amount: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  member_id: order_by
  narration: order_by
  payment_currency: order_by
  payment_response_code: order_by
  payment_state: order_by
  payment_url: order_by
  period_id: order_by
  recipient_name: order_by
  recipient_phone: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "payment"
"""
type payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment!]!
}

"""
input type for inserting object relation for remote table "payment"
"""
input payment_obj_rel_insert_input {
  data: payment_insert_input!

  """upsert condition"""
  on_conflict: payment_on_conflict
}

"""
on_conflict condition type for table "payment"
"""
input payment_on_conflict {
  constraint: payment_constraint!
  update_columns: [payment_update_column!]! = []
  where: payment_bool_exp
}

"""Ordering options when selecting data from "payment"."""
input payment_order_by {
  amount: order_by
  created_at: order_by
  enum_status: en_statuses_order_by
  enum_trans_type: en_trans_types_order_by
  group: group_order_by
  group_id: order_by
  id: order_by
  member: member_order_by
  member_id: order_by
  narration: order_by
  paymentReviewsByPaymentId_aggregate: payment_review_aggregate_order_by
  payment_currency: order_by
  payment_response_code: order_by
  payment_reviews_aggregate: payment_review_aggregate_order_by
  payment_state: order_by
  payment_url: order_by
  period: period_order_by
  period_id: order_by
  recipient_name: order_by
  recipient_phone: order_by
  transaction_status: order_by
  transaction_type: order_by
  updated_at: order_by
}

"""primary key columns input for table: payment"""
input payment_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "payment_review"
"""
type payment_review {
  created_at: timestamptz!

  """An object relationship"""
  en_permission: en_permissions!

  """An object relationship"""
  group: group
  group_id: uuid
  id: uuid!
  index: Int
  notes: String

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """An object relationship"""
  payment: payment!
  payment_id: uuid!

  """An object relationship"""
  period: period!
  period_id: uuid!

  """An object relationship"""
  requester: member
  requester_id: uuid
  response: en_permissions_enum!

  """An object relationship"""
  reviewer: member
  reviewer_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "payment_review"
"""
type payment_review_aggregate {
  aggregate: payment_review_aggregate_fields
  nodes: [payment_review!]!
}

"""
aggregate fields of "payment_review"
"""
type payment_review_aggregate_fields {
  avg: payment_review_avg_fields
  count(columns: [payment_review_select_column!], distinct: Boolean): Int!
  max: payment_review_max_fields
  min: payment_review_min_fields
  stddev: payment_review_stddev_fields
  stddev_pop: payment_review_stddev_pop_fields
  stddev_samp: payment_review_stddev_samp_fields
  sum: payment_review_sum_fields
  var_pop: payment_review_var_pop_fields
  var_samp: payment_review_var_samp_fields
  variance: payment_review_variance_fields
}

"""
order by aggregate values of table "payment_review"
"""
input payment_review_aggregate_order_by {
  avg: payment_review_avg_order_by
  count: order_by
  max: payment_review_max_order_by
  min: payment_review_min_order_by
  stddev: payment_review_stddev_order_by
  stddev_pop: payment_review_stddev_pop_order_by
  stddev_samp: payment_review_stddev_samp_order_by
  sum: payment_review_sum_order_by
  var_pop: payment_review_var_pop_order_by
  var_samp: payment_review_var_samp_order_by
  variance: payment_review_variance_order_by
}

"""
input type for inserting array relation for remote table "payment_review"
"""
input payment_review_arr_rel_insert_input {
  data: [payment_review_insert_input!]!

  """upsert condition"""
  on_conflict: payment_review_on_conflict
}

"""aggregate avg on columns"""
type payment_review_avg_fields {
  index: Float
}

"""
order by avg() on columns of table "payment_review"
"""
input payment_review_avg_order_by {
  index: order_by
}

"""
Boolean expression to filter rows from the table "payment_review". All fields are combined with a logical 'AND'.
"""
input payment_review_bool_exp {
  _and: [payment_review_bool_exp!]
  _not: payment_review_bool_exp
  _or: [payment_review_bool_exp!]
  created_at: timestamptz_comparison_exp
  en_permission: en_permissions_bool_exp
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  index: Int_comparison_exp
  notes: String_comparison_exp
  notifications: notification_bool_exp
  payment: payment_bool_exp
  payment_id: uuid_comparison_exp
  period: period_bool_exp
  period_id: uuid_comparison_exp
  requester: member_bool_exp
  requester_id: uuid_comparison_exp
  response: en_permissions_enum_comparison_exp
  reviewer: member_bool_exp
  reviewer_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payment_review"
"""
enum payment_review_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_permission_pkey
}

"""
input type for incrementing numeric columns in table "payment_review"
"""
input payment_review_inc_input {
  index: Int
}

"""
input type for inserting data into table "payment_review"
"""
input payment_review_insert_input {
  created_at: timestamptz
  en_permission: en_permissions_obj_rel_insert_input
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  index: Int
  notes: String
  notifications: notification_arr_rel_insert_input
  payment: payment_obj_rel_insert_input
  payment_id: uuid
  period: period_obj_rel_insert_input
  period_id: uuid
  requester: member_obj_rel_insert_input
  requester_id: uuid
  response: en_permissions_enum
  reviewer: member_obj_rel_insert_input
  reviewer_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payment_review_max_fields {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  index: Int
  notes: String
  payment_id: uuid
  period_id: uuid
  requester_id: uuid
  reviewer_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "payment_review"
"""
input payment_review_max_order_by {
  created_at: order_by
  group_id: order_by
  id: order_by
  index: order_by
  notes: order_by
  payment_id: order_by
  period_id: order_by
  requester_id: order_by
  reviewer_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type payment_review_min_fields {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  index: Int
  notes: String
  payment_id: uuid
  period_id: uuid
  requester_id: uuid
  reviewer_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "payment_review"
"""
input payment_review_min_order_by {
  created_at: order_by
  group_id: order_by
  id: order_by
  index: order_by
  notes: order_by
  payment_id: order_by
  period_id: order_by
  requester_id: order_by
  reviewer_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "payment_review"
"""
type payment_review_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_review!]!
}

"""
input type for inserting object relation for remote table "payment_review"
"""
input payment_review_obj_rel_insert_input {
  data: payment_review_insert_input!

  """upsert condition"""
  on_conflict: payment_review_on_conflict
}

"""
on_conflict condition type for table "payment_review"
"""
input payment_review_on_conflict {
  constraint: payment_review_constraint!
  update_columns: [payment_review_update_column!]! = []
  where: payment_review_bool_exp
}

"""Ordering options when selecting data from "payment_review"."""
input payment_review_order_by {
  created_at: order_by
  en_permission: en_permissions_order_by
  group: group_order_by
  group_id: order_by
  id: order_by
  index: order_by
  notes: order_by
  notifications_aggregate: notification_aggregate_order_by
  payment: payment_order_by
  payment_id: order_by
  period: period_order_by
  period_id: order_by
  requester: member_order_by
  requester_id: order_by
  response: order_by
  reviewer: member_order_by
  reviewer_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: payment_review"""
input payment_review_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payment_review"
"""
enum payment_review_select_column {
  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  index

  """column name"""
  notes

  """column name"""
  payment_id

  """column name"""
  period_id

  """column name"""
  requester_id

  """column name"""
  response

  """column name"""
  reviewer_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "payment_review"
"""
input payment_review_set_input {
  created_at: timestamptz
  group_id: uuid
  id: uuid
  index: Int
  notes: String
  payment_id: uuid
  period_id: uuid
  requester_id: uuid
  response: en_permissions_enum
  reviewer_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payment_review_stddev_fields {
  index: Float
}

"""
order by stddev() on columns of table "payment_review"
"""
input payment_review_stddev_order_by {
  index: order_by
}

"""aggregate stddev_pop on columns"""
type payment_review_stddev_pop_fields {
  index: Float
}

"""
order by stddev_pop() on columns of table "payment_review"
"""
input payment_review_stddev_pop_order_by {
  index: order_by
}

"""aggregate stddev_samp on columns"""
type payment_review_stddev_samp_fields {
  index: Float
}

"""
order by stddev_samp() on columns of table "payment_review"
"""
input payment_review_stddev_samp_order_by {
  index: order_by
}

"""aggregate sum on columns"""
type payment_review_sum_fields {
  index: Int
}

"""
order by sum() on columns of table "payment_review"
"""
input payment_review_sum_order_by {
  index: order_by
}

"""
update columns of table "payment_review"
"""
enum payment_review_update_column {
  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  index

  """column name"""
  notes

  """column name"""
  payment_id

  """column name"""
  period_id

  """column name"""
  requester_id

  """column name"""
  response

  """column name"""
  reviewer_id

  """column name"""
  updated_at
}

input payment_review_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_review_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_review_set_input
  where: payment_review_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_review_var_pop_fields {
  index: Float
}

"""
order by var_pop() on columns of table "payment_review"
"""
input payment_review_var_pop_order_by {
  index: order_by
}

"""aggregate var_samp on columns"""
type payment_review_var_samp_fields {
  index: Float
}

"""
order by var_samp() on columns of table "payment_review"
"""
input payment_review_var_samp_order_by {
  index: order_by
}

"""aggregate variance on columns"""
type payment_review_variance_fields {
  index: Float
}

"""
order by variance() on columns of table "payment_review"
"""
input payment_review_variance_order_by {
  index: order_by
}

"""
select columns of table "payment"
"""
enum payment_select_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  member_id

  """column name"""
  narration

  """column name"""
  payment_currency

  """column name"""
  payment_response_code

  """column name"""
  payment_state

  """column name"""
  payment_url

  """column name"""
  period_id

  """column name"""
  recipient_name

  """column name"""
  recipient_phone

  """column name"""
  transaction_status

  """column name"""
  transaction_type

  """column name"""
  updated_at
}

"""
input type for updating data in table "payment"
"""
input payment_set_input {
  amount: numeric
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  narration: String
  payment_currency: String
  payment_response_code: String
  payment_state: String
  payment_url: String
  period_id: uuid
  recipient_name: String
  recipient_phone: String
  transaction_status: en_statuses_enum
  transaction_type: en_trans_types_enum
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payment_stddev_fields {
  amount: Float
}

"""
order by stddev() on columns of table "payment"
"""
input payment_stddev_order_by {
  amount: order_by
}

"""aggregate stddev_pop on columns"""
type payment_stddev_pop_fields {
  amount: Float
}

"""
order by stddev_pop() on columns of table "payment"
"""
input payment_stddev_pop_order_by {
  amount: order_by
}

"""aggregate stddev_samp on columns"""
type payment_stddev_samp_fields {
  amount: Float
}

"""
order by stddev_samp() on columns of table "payment"
"""
input payment_stddev_samp_order_by {
  amount: order_by
}

"""aggregate sum on columns"""
type payment_sum_fields {
  amount: numeric
}

"""
order by sum() on columns of table "payment"
"""
input payment_sum_order_by {
  amount: order_by
}

"""
update columns of table "payment"
"""
enum payment_update_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  member_id

  """column name"""
  narration

  """column name"""
  payment_currency

  """column name"""
  payment_response_code

  """column name"""
  payment_state

  """column name"""
  payment_url

  """column name"""
  period_id

  """column name"""
  recipient_name

  """column name"""
  recipient_phone

  """column name"""
  transaction_status

  """column name"""
  transaction_type

  """column name"""
  updated_at
}

input payment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_set_input
  where: payment_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_var_pop_fields {
  amount: Float
}

"""
order by var_pop() on columns of table "payment"
"""
input payment_var_pop_order_by {
  amount: order_by
}

"""aggregate var_samp on columns"""
type payment_var_samp_fields {
  amount: Float
}

"""
order by var_samp() on columns of table "payment"
"""
input payment_var_samp_order_by {
  amount: order_by
}

"""aggregate variance on columns"""
type payment_variance_fields {
  amount: Float
}

"""
order by variance() on columns of table "payment"
"""
input payment_variance_order_by {
  amount: order_by
}

"""
columns and relationships of "period"
"""
type period {
  completed_at: timestamptz!
  created_at: timestamptz!

  """An object relationship"""
  group: group!
  group_id: uuid!
  id: uuid!

  """An object relationship"""
  member: member!
  member_id: uuid!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """An array relationship"""
  payment_requests(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """An aggregate relationship"""
  payment_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!
  period_index: Int!
  reminder_index: Int
  updated_at: timestamptz!
}

"""
aggregated selection of "period"
"""
type period_aggregate {
  aggregate: period_aggregate_fields
  nodes: [period!]!
}

"""
aggregate fields of "period"
"""
type period_aggregate_fields {
  avg: period_avg_fields
  count(columns: [period_select_column!], distinct: Boolean): Int!
  max: period_max_fields
  min: period_min_fields
  stddev: period_stddev_fields
  stddev_pop: period_stddev_pop_fields
  stddev_samp: period_stddev_samp_fields
  sum: period_sum_fields
  var_pop: period_var_pop_fields
  var_samp: period_var_samp_fields
  variance: period_variance_fields
}

"""
order by aggregate values of table "period"
"""
input period_aggregate_order_by {
  avg: period_avg_order_by
  count: order_by
  max: period_max_order_by
  min: period_min_order_by
  stddev: period_stddev_order_by
  stddev_pop: period_stddev_pop_order_by
  stddev_samp: period_stddev_samp_order_by
  sum: period_sum_order_by
  var_pop: period_var_pop_order_by
  var_samp: period_var_samp_order_by
  variance: period_variance_order_by
}

"""
input type for inserting array relation for remote table "period"
"""
input period_arr_rel_insert_input {
  data: [period_insert_input!]!

  """upsert condition"""
  on_conflict: period_on_conflict
}

"""aggregate avg on columns"""
type period_avg_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by avg() on columns of table "period"
"""
input period_avg_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""
Boolean expression to filter rows from the table "period". All fields are combined with a logical 'AND'.
"""
input period_bool_exp {
  _and: [period_bool_exp!]
  _not: period_bool_exp
  _or: [period_bool_exp!]
  completed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  group: group_bool_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  member: member_bool_exp
  member_id: uuid_comparison_exp
  notifications: notification_bool_exp
  payment_requests: payment_review_bool_exp
  payments: payment_bool_exp
  period_index: Int_comparison_exp
  reminder_index: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "period"
"""
enum period_constraint {
  """
  unique or primary key constraint on columns "member_id", "period_index", "group_id"
  """
  period_group_id_member_id_period_index_key

  """
  unique or primary key constraint on columns "id"
  """
  period_pkey
}

"""
input type for incrementing numeric columns in table "period"
"""
input period_inc_input {
  period_index: Int
  reminder_index: Int
}

"""
input type for inserting data into table "period"
"""
input period_insert_input {
  completed_at: timestamptz
  created_at: timestamptz
  group: group_obj_rel_insert_input
  group_id: uuid
  id: uuid
  member: member_obj_rel_insert_input
  member_id: uuid
  notifications: notification_arr_rel_insert_input
  payment_requests: payment_review_arr_rel_insert_input
  payments: payment_arr_rel_insert_input
  period_index: Int
  reminder_index: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type period_max_fields {
  completed_at: timestamptz
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  period_index: Int
  reminder_index: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "period"
"""
input period_max_order_by {
  completed_at: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  member_id: order_by
  period_index: order_by
  reminder_index: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type period_min_fields {
  completed_at: timestamptz
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  period_index: Int
  reminder_index: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "period"
"""
input period_min_order_by {
  completed_at: order_by
  created_at: order_by
  group_id: order_by
  id: order_by
  member_id: order_by
  period_index: order_by
  reminder_index: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "period"
"""
type period_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [period!]!
}

"""
input type for inserting object relation for remote table "period"
"""
input period_obj_rel_insert_input {
  data: period_insert_input!

  """upsert condition"""
  on_conflict: period_on_conflict
}

"""
on_conflict condition type for table "period"
"""
input period_on_conflict {
  constraint: period_constraint!
  update_columns: [period_update_column!]! = []
  where: period_bool_exp
}

"""Ordering options when selecting data from "period"."""
input period_order_by {
  completed_at: order_by
  created_at: order_by
  group: group_order_by
  group_id: order_by
  id: order_by
  member: member_order_by
  member_id: order_by
  notifications_aggregate: notification_aggregate_order_by
  payment_requests_aggregate: payment_review_aggregate_order_by
  payments_aggregate: payment_aggregate_order_by
  period_index: order_by
  reminder_index: order_by
  updated_at: order_by
}

"""primary key columns input for table: period"""
input period_pk_columns_input {
  id: uuid!
}

"""
select columns of table "period"
"""
enum period_select_column {
  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  member_id

  """column name"""
  period_index

  """column name"""
  reminder_index

  """column name"""
  updated_at
}

"""
input type for updating data in table "period"
"""
input period_set_input {
  completed_at: timestamptz
  created_at: timestamptz
  group_id: uuid
  id: uuid
  member_id: uuid
  period_index: Int
  reminder_index: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type period_stddev_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by stddev() on columns of table "period"
"""
input period_stddev_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""aggregate stddev_pop on columns"""
type period_stddev_pop_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by stddev_pop() on columns of table "period"
"""
input period_stddev_pop_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""aggregate stddev_samp on columns"""
type period_stddev_samp_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by stddev_samp() on columns of table "period"
"""
input period_stddev_samp_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""aggregate sum on columns"""
type period_sum_fields {
  period_index: Int
  reminder_index: Int
}

"""
order by sum() on columns of table "period"
"""
input period_sum_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""
update columns of table "period"
"""
enum period_update_column {
  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  group_id

  """column name"""
  id

  """column name"""
  member_id

  """column name"""
  period_index

  """column name"""
  reminder_index

  """column name"""
  updated_at
}

input period_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: period_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: period_set_input
  where: period_bool_exp!
}

"""aggregate var_pop on columns"""
type period_var_pop_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by var_pop() on columns of table "period"
"""
input period_var_pop_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""aggregate var_samp on columns"""
type period_var_samp_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by var_samp() on columns of table "period"
"""
input period_var_samp_order_by {
  period_index: order_by
  reminder_index: order_by
}

"""aggregate variance on columns"""
type period_variance_fields {
  period_index: Float
  reminder_index: Float
}

"""
order by variance() on columns of table "period"
"""
input period_variance_order_by {
  period_index: order_by
  reminder_index: order_by
}

type query_root {
  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_authenticators" using primary key columns
  """
  authUserAuthenticator(id: uuid!): authUserAuthenticators

  """
  fetch data from the table: "auth.user_authenticators"
  """
  authUserAuthenticators(
    """distinct select on columns"""
    distinct_on: [authUserAuthenticators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserAuthenticators_order_by!]

    """filter the rows returned"""
    where: authUserAuthenticators_bool_exp
  ): [authUserAuthenticators!]!

  """
  fetch aggregated fields from the table: "auth.user_authenticators"
  """
  authUserAuthenticatorsAggregate(
    """distinct select on columns"""
    distinct_on: [authUserAuthenticators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserAuthenticators_order_by!]

    """filter the rows returned"""
    where: authUserAuthenticators_bool_exp
  ): authUserAuthenticators_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.migrations"
  """
  auth_migrations(
    """distinct select on columns"""
    distinct_on: [auth_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_migrations_order_by!]

    """filter the rows returned"""
    where: auth_migrations_bool_exp
  ): [auth_migrations!]!

  """
  fetch aggregated fields from the table: "auth.migrations"
  """
  auth_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_migrations_order_by!]

    """filter the rows returned"""
    where: auth_migrations_bool_exp
  ): auth_migrations_aggregate!

  """fetch data from the table: "auth.migrations" using primary key columns"""
  auth_migrations_by_pk(id: Int!): auth_migrations

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "en_notifications"
  """
  en_notifications(
    """distinct select on columns"""
    distinct_on: [en_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_notifications_order_by!]

    """filter the rows returned"""
    where: en_notifications_bool_exp
  ): [en_notifications!]!

  """
  fetch aggregated fields from the table: "en_notifications"
  """
  en_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [en_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_notifications_order_by!]

    """filter the rows returned"""
    where: en_notifications_bool_exp
  ): en_notifications_aggregate!

  """
  fetch data from the table: "en_notifications" using primary key columns
  """
  en_notifications_by_pk(value: String!): en_notifications

  """
  fetch data from the table: "en_permissions"
  """
  en_permissions(
    """distinct select on columns"""
    distinct_on: [en_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_permissions_order_by!]

    """filter the rows returned"""
    where: en_permissions_bool_exp
  ): [en_permissions!]!

  """
  fetch aggregated fields from the table: "en_permissions"
  """
  en_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [en_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_permissions_order_by!]

    """filter the rows returned"""
    where: en_permissions_bool_exp
  ): en_permissions_aggregate!

  """fetch data from the table: "en_permissions" using primary key columns"""
  en_permissions_by_pk(value: String!): en_permissions

  """
  fetch data from the table: "en_recurrencies"
  """
  en_recurrencies(
    """distinct select on columns"""
    distinct_on: [en_recurrencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_recurrencies_order_by!]

    """filter the rows returned"""
    where: en_recurrencies_bool_exp
  ): [en_recurrencies!]!

  """
  fetch aggregated fields from the table: "en_recurrencies"
  """
  en_recurrencies_aggregate(
    """distinct select on columns"""
    distinct_on: [en_recurrencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_recurrencies_order_by!]

    """filter the rows returned"""
    where: en_recurrencies_bool_exp
  ): en_recurrencies_aggregate!

  """fetch data from the table: "en_recurrencies" using primary key columns"""
  en_recurrencies_by_pk(value: String!): en_recurrencies

  """
  fetch data from the table: "en_statuses"
  """
  en_statuses(
    """distinct select on columns"""
    distinct_on: [en_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_statuses_order_by!]

    """filter the rows returned"""
    where: en_statuses_bool_exp
  ): [en_statuses!]!

  """
  fetch aggregated fields from the table: "en_statuses"
  """
  en_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [en_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_statuses_order_by!]

    """filter the rows returned"""
    where: en_statuses_bool_exp
  ): en_statuses_aggregate!

  """fetch data from the table: "en_statuses" using primary key columns"""
  en_statuses_by_pk(value: String!): en_statuses

  """
  fetch data from the table: "en_trans_types"
  """
  en_trans_types(
    """distinct select on columns"""
    distinct_on: [en_trans_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_trans_types_order_by!]

    """filter the rows returned"""
    where: en_trans_types_bool_exp
  ): [en_trans_types!]!

  """
  fetch aggregated fields from the table: "en_trans_types"
  """
  en_trans_types_aggregate(
    """distinct select on columns"""
    distinct_on: [en_trans_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_trans_types_order_by!]

    """filter the rows returned"""
    where: en_trans_types_bool_exp
  ): en_trans_types_aggregate!

  """fetch data from the table: "en_trans_types" using primary key columns"""
  en_trans_types_by_pk(value: String!): en_trans_types

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table: "group"
  """
  group(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """
  fetch aggregated fields from the table: "group"
  """
  group_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!

  """fetch data from the table: "group" using primary key columns"""
  group_by_pk(id: uuid!): group

  """
  fetch data from the table: "invitation"
  """
  invitation(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """
  fetch aggregated fields from the table: "invitation"
  """
  invitation_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!

  """fetch data from the table: "invitation" using primary key columns"""
  invitation_by_pk(id: uuid!): invitation

  """
  fetch data from the table: "member"
  """
  member(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """
  fetch aggregated fields from the table: "member"
  """
  member_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!

  """fetch data from the table: "member" using primary key columns"""
  member_by_pk(id: uuid!): member

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "payment"
  """
  payment(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """
  fetch aggregated fields from the table: "payment"
  """
  payment_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """fetch data from the table: "payment" using primary key columns"""
  payment_by_pk(id: uuid!): payment

  """
  fetch data from the table: "payment_review"
  """
  payment_review(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """
  fetch aggregated fields from the table: "payment_review"
  """
  payment_review_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!

  """fetch data from the table: "payment_review" using primary key columns"""
  payment_review_by_pk(id: uuid!): payment_review

  """
  fetch data from the table: "period"
  """
  period(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): [period!]!

  """
  fetch aggregated fields from the table: "period"
  """
  period_aggregate(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): period_aggregate!

  """fetch data from the table: "period" using primary key columns"""
  period_by_pk(id: uuid!): period

  """
  fetch data from the table: "state_cache"
  """
  state_cache(
    """distinct select on columns"""
    distinct_on: [state_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [state_cache_order_by!]

    """filter the rows returned"""
    where: state_cache_bool_exp
  ): [state_cache!]!

  """
  fetch aggregated fields from the table: "state_cache"
  """
  state_cache_aggregate(
    """distinct select on columns"""
    distinct_on: [state_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [state_cache_order_by!]

    """filter the rows returned"""
    where: state_cache_bool_exp
  ): state_cache_aggregate!

  """fetch data from the table: "state_cache" using primary key columns"""
  state_cache_by_pk(id: uuid!): state_cache

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "user_profile"
  """
  user_profile(
    """distinct select on columns"""
    distinct_on: [user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profile_order_by!]

    """filter the rows returned"""
    where: user_profile_bool_exp
  ): [user_profile!]!

  """
  fetch aggregated fields from the table: "user_profile"
  """
  user_profile_aggregate(
    """distinct select on columns"""
    distinct_on: [user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profile_order_by!]

    """filter the rows returned"""
    where: user_profile_bool_exp
  ): user_profile_aggregate!

  """fetch data from the table: "user_profile" using primary key columns"""
  user_profile_by_pk(id: uuid!): user_profile

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
columns and relationships of "state_cache"
"""
type state_cache {
  created_at: timestamptz!
  id: uuid!
  ref_id: uuid!
  state: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "state_cache"
"""
type state_cache_aggregate {
  aggregate: state_cache_aggregate_fields
  nodes: [state_cache!]!
}

"""
aggregate fields of "state_cache"
"""
type state_cache_aggregate_fields {
  count(columns: [state_cache_select_column!], distinct: Boolean): Int!
  max: state_cache_max_fields
  min: state_cache_min_fields
}

"""
Boolean expression to filter rows from the table "state_cache". All fields are combined with a logical 'AND'.
"""
input state_cache_bool_exp {
  _and: [state_cache_bool_exp!]
  _not: state_cache_bool_exp
  _or: [state_cache_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  ref_id: uuid_comparison_exp
  state: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "state_cache"
"""
enum state_cache_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  state_cache_pkey
}

"""
input type for inserting data into table "state_cache"
"""
input state_cache_insert_input {
  created_at: timestamptz
  id: uuid
  ref_id: uuid
  state: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type state_cache_max_fields {
  created_at: timestamptz
  id: uuid
  ref_id: uuid
  state: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type state_cache_min_fields {
  created_at: timestamptz
  id: uuid
  ref_id: uuid
  state: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "state_cache"
"""
type state_cache_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [state_cache!]!
}

"""
on_conflict condition type for table "state_cache"
"""
input state_cache_on_conflict {
  constraint: state_cache_constraint!
  update_columns: [state_cache_update_column!]! = []
  where: state_cache_bool_exp
}

"""Ordering options when selecting data from "state_cache"."""
input state_cache_order_by {
  created_at: order_by
  id: order_by
  ref_id: order_by
  state: order_by
  updated_at: order_by
}

"""primary key columns input for table: state_cache"""
input state_cache_pk_columns_input {
  id: uuid!
}

"""
select columns of table "state_cache"
"""
enum state_cache_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  ref_id

  """column name"""
  state

  """column name"""
  updated_at
}

"""
input type for updating data in table "state_cache"
"""
input state_cache_set_input {
  created_at: timestamptz
  id: uuid
  ref_id: uuid
  state: String
  updated_at: timestamptz
}

"""
update columns of table "state_cache"
"""
enum state_cache_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  ref_id

  """column name"""
  state

  """column name"""
  updated_at
}

input state_cache_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: state_cache_set_input
  where: state_cache_bool_exp!
}

type subscription_root {
  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_authenticators" using primary key columns
  """
  authUserAuthenticator(id: uuid!): authUserAuthenticators

  """
  fetch data from the table: "auth.user_authenticators"
  """
  authUserAuthenticators(
    """distinct select on columns"""
    distinct_on: [authUserAuthenticators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserAuthenticators_order_by!]

    """filter the rows returned"""
    where: authUserAuthenticators_bool_exp
  ): [authUserAuthenticators!]!

  """
  fetch aggregated fields from the table: "auth.user_authenticators"
  """
  authUserAuthenticatorsAggregate(
    """distinct select on columns"""
    distinct_on: [authUserAuthenticators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserAuthenticators_order_by!]

    """filter the rows returned"""
    where: authUserAuthenticators_bool_exp
  ): authUserAuthenticators_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.migrations"
  """
  auth_migrations(
    """distinct select on columns"""
    distinct_on: [auth_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_migrations_order_by!]

    """filter the rows returned"""
    where: auth_migrations_bool_exp
  ): [auth_migrations!]!

  """
  fetch aggregated fields from the table: "auth.migrations"
  """
  auth_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_migrations_order_by!]

    """filter the rows returned"""
    where: auth_migrations_bool_exp
  ): auth_migrations_aggregate!

  """fetch data from the table: "auth.migrations" using primary key columns"""
  auth_migrations_by_pk(id: Int!): auth_migrations

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "en_notifications"
  """
  en_notifications(
    """distinct select on columns"""
    distinct_on: [en_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_notifications_order_by!]

    """filter the rows returned"""
    where: en_notifications_bool_exp
  ): [en_notifications!]!

  """
  fetch aggregated fields from the table: "en_notifications"
  """
  en_notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [en_notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_notifications_order_by!]

    """filter the rows returned"""
    where: en_notifications_bool_exp
  ): en_notifications_aggregate!

  """
  fetch data from the table: "en_notifications" using primary key columns
  """
  en_notifications_by_pk(value: String!): en_notifications

  """
  fetch data from the table: "en_permissions"
  """
  en_permissions(
    """distinct select on columns"""
    distinct_on: [en_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_permissions_order_by!]

    """filter the rows returned"""
    where: en_permissions_bool_exp
  ): [en_permissions!]!

  """
  fetch aggregated fields from the table: "en_permissions"
  """
  en_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [en_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_permissions_order_by!]

    """filter the rows returned"""
    where: en_permissions_bool_exp
  ): en_permissions_aggregate!

  """fetch data from the table: "en_permissions" using primary key columns"""
  en_permissions_by_pk(value: String!): en_permissions

  """
  fetch data from the table: "en_recurrencies"
  """
  en_recurrencies(
    """distinct select on columns"""
    distinct_on: [en_recurrencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_recurrencies_order_by!]

    """filter the rows returned"""
    where: en_recurrencies_bool_exp
  ): [en_recurrencies!]!

  """
  fetch aggregated fields from the table: "en_recurrencies"
  """
  en_recurrencies_aggregate(
    """distinct select on columns"""
    distinct_on: [en_recurrencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_recurrencies_order_by!]

    """filter the rows returned"""
    where: en_recurrencies_bool_exp
  ): en_recurrencies_aggregate!

  """fetch data from the table: "en_recurrencies" using primary key columns"""
  en_recurrencies_by_pk(value: String!): en_recurrencies

  """
  fetch data from the table: "en_statuses"
  """
  en_statuses(
    """distinct select on columns"""
    distinct_on: [en_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_statuses_order_by!]

    """filter the rows returned"""
    where: en_statuses_bool_exp
  ): [en_statuses!]!

  """
  fetch aggregated fields from the table: "en_statuses"
  """
  en_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [en_statuses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_statuses_order_by!]

    """filter the rows returned"""
    where: en_statuses_bool_exp
  ): en_statuses_aggregate!

  """fetch data from the table: "en_statuses" using primary key columns"""
  en_statuses_by_pk(value: String!): en_statuses

  """
  fetch data from the table: "en_trans_types"
  """
  en_trans_types(
    """distinct select on columns"""
    distinct_on: [en_trans_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_trans_types_order_by!]

    """filter the rows returned"""
    where: en_trans_types_bool_exp
  ): [en_trans_types!]!

  """
  fetch aggregated fields from the table: "en_trans_types"
  """
  en_trans_types_aggregate(
    """distinct select on columns"""
    distinct_on: [en_trans_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [en_trans_types_order_by!]

    """filter the rows returned"""
    where: en_trans_types_bool_exp
  ): en_trans_types_aggregate!

  """fetch data from the table: "en_trans_types" using primary key columns"""
  en_trans_types_by_pk(value: String!): en_trans_types

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table: "group"
  """
  group(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """
  fetch aggregated fields from the table: "group"
  """
  group_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!

  """fetch data from the table: "group" using primary key columns"""
  group_by_pk(id: uuid!): group

  """
  fetch data from the table: "invitation"
  """
  invitation(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """
  fetch aggregated fields from the table: "invitation"
  """
  invitation_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!

  """fetch data from the table: "invitation" using primary key columns"""
  invitation_by_pk(id: uuid!): invitation

  """
  fetch data from the table: "member"
  """
  member(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """
  fetch aggregated fields from the table: "member"
  """
  member_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!

  """fetch data from the table: "member" using primary key columns"""
  member_by_pk(id: uuid!): member

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "payment"
  """
  payment(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """
  fetch aggregated fields from the table: "payment"
  """
  payment_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """fetch data from the table: "payment" using primary key columns"""
  payment_by_pk(id: uuid!): payment

  """
  fetch data from the table: "payment_review"
  """
  payment_review(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): [payment_review!]!

  """
  fetch aggregated fields from the table: "payment_review"
  """
  payment_review_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_review_order_by!]

    """filter the rows returned"""
    where: payment_review_bool_exp
  ): payment_review_aggregate!

  """fetch data from the table: "payment_review" using primary key columns"""
  payment_review_by_pk(id: uuid!): payment_review

  """
  fetch data from the table: "period"
  """
  period(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): [period!]!

  """
  fetch aggregated fields from the table: "period"
  """
  period_aggregate(
    """distinct select on columns"""
    distinct_on: [period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [period_order_by!]

    """filter the rows returned"""
    where: period_bool_exp
  ): period_aggregate!

  """fetch data from the table: "period" using primary key columns"""
  period_by_pk(id: uuid!): period

  """
  fetch data from the table: "state_cache"
  """
  state_cache(
    """distinct select on columns"""
    distinct_on: [state_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [state_cache_order_by!]

    """filter the rows returned"""
    where: state_cache_bool_exp
  ): [state_cache!]!

  """
  fetch aggregated fields from the table: "state_cache"
  """
  state_cache_aggregate(
    """distinct select on columns"""
    distinct_on: [state_cache_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [state_cache_order_by!]

    """filter the rows returned"""
    where: state_cache_bool_exp
  ): state_cache_aggregate!

  """fetch data from the table: "state_cache" using primary key columns"""
  state_cache_by_pk(id: uuid!): state_cache

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "user_profile"
  """
  user_profile(
    """distinct select on columns"""
    distinct_on: [user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profile_order_by!]

    """filter the rows returned"""
    where: user_profile_bool_exp
  ): [user_profile!]!

  """
  fetch aggregated fields from the table: "user_profile"
  """
  user_profile_aggregate(
    """distinct select on columns"""
    distinct_on: [user_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_profile_order_by!]

    """filter the rows returned"""
    where: user_profile_bool_exp
  ): user_profile_aggregate!

  """fetch data from the table: "user_profile" using primary key columns"""
  user_profile_by_pk(id: uuid!): user_profile

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_profile"
"""
type user_profile {
  created_at: timestamptz
  expo_push_token: String!
  id: uuid!
  updated_at: timestamptz

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_profile"
"""
type user_profile_aggregate {
  aggregate: user_profile_aggregate_fields
  nodes: [user_profile!]!
}

"""
aggregate fields of "user_profile"
"""
type user_profile_aggregate_fields {
  count(columns: [user_profile_select_column!], distinct: Boolean): Int!
  max: user_profile_max_fields
  min: user_profile_min_fields
}

"""
Boolean expression to filter rows from the table "user_profile". All fields are combined with a logical 'AND'.
"""
input user_profile_bool_exp {
  _and: [user_profile_bool_exp!]
  _not: user_profile_bool_exp
  _or: [user_profile_bool_exp!]
  created_at: timestamptz_comparison_exp
  expo_push_token: String_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_profile"
"""
enum user_profile_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_profile_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  user_profile_user_id_key
}

"""
input type for inserting data into table "user_profile"
"""
input user_profile_insert_input {
  created_at: timestamptz
  expo_push_token: String
  id: uuid
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_profile_max_fields {
  created_at: timestamptz
  expo_push_token: String
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_profile_min_fields {
  created_at: timestamptz
  expo_push_token: String
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_profile"
"""
type user_profile_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_profile!]!
}

"""
input type for inserting object relation for remote table "user_profile"
"""
input user_profile_obj_rel_insert_input {
  data: user_profile_insert_input!

  """upsert condition"""
  on_conflict: user_profile_on_conflict
}

"""
on_conflict condition type for table "user_profile"
"""
input user_profile_on_conflict {
  constraint: user_profile_constraint!
  update_columns: [user_profile_update_column!]! = []
  where: user_profile_bool_exp
}

"""Ordering options when selecting data from "user_profile"."""
input user_profile_order_by {
  created_at: order_by
  expo_push_token: order_by
  id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_profile"""
input user_profile_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_profile"
"""
enum user_profile_select_column {
  """column name"""
  created_at

  """column name"""
  expo_push_token

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_profile"
"""
input user_profile_set_input {
  created_at: timestamptz
  expo_push_token: String
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "user_profile"
"""
enum user_profile_update_column {
  """column name"""
  created_at

  """column name"""
  expo_push_token

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_profile_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_profile_set_input
  where: user_profile_bool_exp!
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String

  """An array relationship"""
  authenticators(
    """distinct select on columns"""
    distinct_on: [authUserAuthenticators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserAuthenticators_order_by!]

    """filter the rows returned"""
    where: authUserAuthenticators_bool_exp
  ): [authUserAuthenticators!]!

  """An aggregate relationship"""
  authenticators_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserAuthenticators_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserAuthenticators_order_by!]

    """filter the rows returned"""
    where: authUserAuthenticators_bool_exp
  ): authUserAuthenticators_aggregate!
  avatarUrl: String!
  createdAt: timestamptz!
  currentChallenge: String
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!
  email: citext
  emailVerified: Boolean!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!
  id: uuid!

  """An array relationship"""
  invitations(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """An array relationship"""
  invitationsBySenderId(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): [invitation!]!

  """An aggregate relationship"""
  invitationsBySenderId_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!

  """An aggregate relationship"""
  invitations_aggregate(
    """distinct select on columns"""
    distinct_on: [invitation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invitation_order_by!]

    """filter the rows returned"""
    where: invitation_bool_exp
  ): invitation_aggregate!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): [member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [member_order_by!]

    """filter the rows returned"""
    where: member_bool_exp
  ): member_aggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]

    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """An object relationship"""
  user_profile: user_profile
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  authenticators: authUserAuthenticators_bool_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentChallenge: String_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  groups: group_bool_exp
  id: uuid_comparison_exp
  invitations: invitation_bool_exp
  invitationsBySenderId: invitation_bool_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  members: member_bool_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  notifications: notification_bool_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  roles: authUserRoles_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
  user_profile: user_profile_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  users_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  authenticators: authUserAuthenticators_arr_rel_insert_input
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  groups: group_arr_rel_insert_input
  id: uuid
  invitations: invitation_arr_rel_insert_input
  invitationsBySenderId: invitation_arr_rel_insert_input
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  members: member_arr_rel_insert_input
  metadata: jsonb
  newEmail: citext
  notifications: notification_arr_rel_insert_input
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
  user_profile: user_profile_obj_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  authenticators_aggregate: authUserAuthenticators_aggregate_order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  email: order_by
  emailVerified: order_by
  groups_aggregate: group_aggregate_order_by
  id: order_by
  invitationsBySenderId_aggregate: invitation_aggregate_order_by
  invitations_aggregate: invitation_aggregate_order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  members_aggregate: member_aggregate_order_by
  metadata: order_by
  newEmail: order_by
  notifications_aggregate: notification_aggregate_order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
  user_profile: user_profile_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}